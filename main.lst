CCS PCH C Compiler, Version 5.025, 40073               10-Thg11-17 12:48

               Filename:   D:\du lieu\BSD\BSD datasheet\MAX31855\Max31855-18F248\main.lst

               ROM used:   9430 bytes (58%)
                           Largest free fragment is 6950
               RAM used:   71 (9%) at main() level
                           137 (18%) worst case
               Stack used: 5 locations (4 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   1E4A
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.1
0056:  GOTO   0060
005A:  BTFSC  F9E.1
005C:  GOTO   0336
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                            EX_CAN.C                             //// 
.................... ////                                                                 //// 
.................... //// Example of CCS's CAN library, using the PIC18Fxx8.  This        //// 
.................... //// example was tested using MCP250xxx CAN Developer's Kit.         //// 
.................... ////                                                                 //// 
.................... //// Connect pin B2 (CANTX) to the CANTX pin on the open NODE A of   //// 
.................... //// the developer's kit, and connect pin B3 (CANRX) to the CANRX    //// 
.................... //// pin on the open NODE A.                                         //// 
.................... ////                                                                 //// 
.................... //// NODE B has an MCP250xxx which sends and responds certan canned  //// 
.................... //// messages.  For example, hitting one of the GPX buttons on       //// 
.................... //// the development kit causes the MCP250xxx to send a 2 byte       //// 
.................... //// message with an ID of 0x290.  After pressing one of those       //// 
.................... //// buttons with this firmware you should see this message          //// 
.................... //// displayed over RS232.                                           //// 
.................... ////                                                                 //// 
.................... //// NODE B also responds to certain CAN messages.  If you send      //// 
.................... //// a request (RTR bit set) with an ID of 0x18 then NODE B will     //// 
.................... //// respond with an 8-byte message containing certain readings.     //// 
.................... //// This firmware sends this request every 2 seconds, which NODE B  //// 
.................... //// responds.                                                       //// 
.................... ////                                                                 //// 
.................... //// If you install Microchip's CANKing software and use the         //// 
.................... //// MCP250xxx , you can see all the CAN traffic and validate all    //// 
.................... //// experiments.                                                    //// 
.................... ////                                                                 //// 
.................... //// For more documentation on the CCS CAN library, see can-18xxx8.c //// 
.................... ////                                                                 //// 
.................... ////  Jumpers:                                                       //// 
.................... ////     PCM,PCH    pin C7 to RS232 RX, pin C6 to RS232 TX           //// 
.................... ////                                                                 //// 
.................... ////  This example will work with the PCM and PCH compilers.         //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... //#include <18F248.h> 
.................... #include <18F2480.h> 
.................... //////////// Standard Header file for the PIC18F2480 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F2480 
00AE:  ADDLW  BC
00B0:  MOVWF  FF6
00B2:  MOVLW  00
00B4:  ADDWFC FF7,F
00B6:  TBLRD*+
00B8:  MOVF   FF5,W
00BA:  RETURN 0
00BC:  DATA 00,00
00BE:  DATA 27,00
00C0:  DATA 4F,00
00C2:  DATA 76,00
00C4:  DATA 9D,00
00C6:  DATA C5,00
00C8:  DATA EC,00
00CA:  DATA 13,01
00CC:  DATA 3A,01
00CE:  DATA 61,01
00D0:  DATA 88,01
00D2:  DATA AF,01
00D4:  DATA D6,01
00D6:  DATA FC,01
00D8:  DATA 23,02
00DA:  DATA 4A,02
00DC:  DATA 70,02
00DE:  DATA 97,02
00E0:  DATA BD,02
00E2:  DATA E3,02
00E4:  DATA 0A,03
00E6:  DATA 30,03
00E8:  DATA 56,03
00EA:  DATA 7C,03
00EC:  DATA A2,03
00EE:  DATA C8,03
00F0:  DATA EE,03
00F2:  DATA 13,04
00F4:  DATA 39,04
00F6:  DATA 5F,04
00F8:  DATA 84,04
00FA:  DATA AA,04
00FC:  DATA CF,04
00FE:  DATA F4,04
0100:  DATA 19,05
0102:  DATA 3F,05
0104:  DATA 64,05
0106:  DATA 89,05
0108:  DATA AD,05
010A:  DATA D2,05
010C:  DATA F7,05
010E:  DATA 1C,06
0110:  DATA 40,06
0112:  DATA 65,06
0114:  DATA 89,06
0116:  DATA AD,06
0118:  DATA D1,06
011A:  DATA F6,06
011C:  DATA 1A,07
011E:  DATA 3E,07
0120:  DATA 61,07
0122:  DATA 85,07
0124:  DATA A9,07
0126:  DATA CC,07
0128:  DATA F0,07
012A:  DATA 13,08
012C:  DATA 37,08
012E:  DATA 5A,08
0130:  DATA 7D,08
0132:  DATA A0,08
0134:  DATA C3,08
0136:  DATA E6,08
0138:  DATA 08,09
013A:  DATA 2B,09
013C:  DATA 4E,09
013E:  DATA 70,09
0140:  DATA 92,09
0142:  DATA B5,09
0144:  DATA D7,09
0146:  DATA F9,09
0148:  DATA 1B,0A
014A:  DATA 3C,0A
014C:  DATA 5E,0A
014E:  DATA 80,0A
0150:  DATA A1,0A
0152:  DATA C3,0A
0154:  DATA E4,0A
0156:  DATA 05,0B
0158:  DATA 26,0B
015A:  DATA 47,0B
015C:  DATA 68,0B
015E:  DATA 89,0B
0160:  DATA AA,0B
0162:  DATA CA,0B
0164:  DATA EA,0B
0166:  DATA 0B,0C
0168:  DATA 2B,0C
016A:  DATA 4B,0C
016C:  DATA 6B,0C
016E:  DATA 8B,0C
0170:  DATA AB,0C
0172:  DATA CA,0C
0174:  DATA EA,0C
0176:  DATA 09,0D
0178:  DATA 28,0D
017A:  DATA 48,0D
017C:  DATA 67,0D
017E:  DATA 86,0D
0180:  DATA A4,0D
0182:  DATA C3,0D
0184:  DATA E2,0D
0186:  DATA 00,0E
0188:  DATA 1E,0E
018A:  DATA 3D,0E
018C:  DATA 5B,0E
018E:  DATA 79,0E
0190:  DATA 96,0E
0192:  DATA B4,0E
0194:  DATA D2,0E
0196:  DATA EF,0E
0198:  DATA 0C,0F
019A:  DATA 2A,0F
019C:  DATA 47,0F
019E:  DATA 63,0F
01A0:  DATA 80,0F
01A2:  DATA 9D,0F
01A4:  DATA B9,0F
01A6:  DATA D6,0F
01A8:  DATA F2,0F
01AA:  DATA 0E,10
01AC:  DATA 2A,10
01AE:  DATA 46,10
01B0:  DATA 62,10
01B2:  DATA 7D,10
01B4:  DATA 99,10
01B6:  DATA B4,10
01B8:  DATA CF,10
01BA:  DATA EA,10
01BC:  DATA 05,11
01BE:  DATA 20,11
01C0:  DATA 3B,11
01C2:  DATA 55,11
01C4:  DATA 6F,11
01C6:  DATA 8A,11
01C8:  DATA A4,11
01CA:  DATA BE,11
01CC:  DATA D7,11
01CE:  DATA F1,11
01D0:  DATA 0A,12
01D2:  DATA 24,12
01D4:  DATA 3D,12
01D6:  DATA 56,12
01D8:  DATA 6F,12
01DA:  DATA 88,12
01DC:  DATA A0,12
01DE:  DATA B9,12
01E0:  DATA D1,12
01E2:  DATA E9,12
01E4:  DATA 01,13
01E6:  DATA 19,13
01E8:  ADDLW  F6
01EA:  MOVWF  FF6
01EC:  MOVLW  01
01EE:  ADDWFC FF7,F
01F0:  TBLRD*+
01F2:  MOVF   FF5,W
01F4:  RETURN 0
01F6:  DATA 00,00
01F8:  DATA 27,00
01FA:  DATA 4F,00
01FC:  DATA 77,00
01FE:  DATA 9E,00
0200:  DATA C6,00
0202:  DATA EE,00
0204:  DATA 15,01
0206:  DATA 3D,01
0208:  DATA 65,01
020A:  DATA 8D,01
020C:  DATA B5,01
020E:  DATA DD,01
0210:  DATA 05,02
0212:  DATA 2D,02
0214:  DATA 55,02
0216:  DATA 7D,02
0218:  DATA A5,02
021A:  DATA CE,02
021C:  DATA F6,02
021E:  DATA 1E,03
0220:  DATA 46,03
0222:  DATA 6F,03
0224:  DATA 97,03
0226:  DATA C0,03
0228:  DATA E8,03
022A:  DATA 11,04
022C:  DATA 39,04
022E:  DATA 62,04
0230:  DATA 8B,04
0232:  DATA B3,04
0234:  DATA DC,04
0236:  DATA 05,05
0238:  DATA 2E,05
023A:  DATA 56,05
023C:  DATA 7F,05
023E:  DATA A8,05
0240:  DATA D1,05
0242:  DATA FA,05
0244:  DATA 23,06
0246:  DATA 4C,06
0248:  DATA 75,06
024A:  DATA 9E,06
024C:  DATA C7,06
024E:  DATA F0,06
0250:  DATA 19,07
0252:  DATA 42,07
0254:  DATA 6B,07
0256:  DATA 95,07
0258:  DATA BE,07
025A:  DATA E7,07
025C:  DATA 10,08
025E:  DATA 3A,08
0260:  DATA 63,08
0262:  DATA 8C,08
0264:  DATA B6,08
0266:  DATA DF,08
0268:  DATA 08,09
026A:  DATA 32,09
026C:  DATA 5B,09
026E:  DATA 84,09
0270:  DATA AE,09
0272:  DATA D7,09
0274:  DATA 01,0A
0276:  DATA 2A,0A
0278:  DATA 54,0A
027A:  DATA 7D,0A
027C:  DATA A7,0A
027E:  DATA D0,0A
0280:  DATA FA,0A
0282:  DATA 23,0B
0284:  DATA 4D,0B
0286:  DATA 76,0B
0288:  DATA A0,0B
028A:  DATA C9,0B
028C:  DATA F3,0B
028E:  DATA 1C,0C
0290:  DATA 46,0C
0292:  DATA 70,0C
0294:  DATA 99,0C
0296:  DATA C3,0C
0298:  DATA EC,0C
029A:  DATA 16,0D
029C:  DATA 3F,0D
029E:  DATA 69,0D
02A0:  DATA 92,0D
02A2:  DATA BC,0D
02A4:  DATA E5,0D
02A6:  DATA 0F,0E
02A8:  DATA 38,0E
02AA:  DATA 62,0E
02AC:  DATA 8B,0E
02AE:  DATA B5,0E
02B0:  DATA DE,0E
02B2:  DATA 08,0F
02B4:  DATA 31,0F
02B6:  DATA 5B,0F
02B8:  DATA 84,0F
02BA:  DATA AD,0F
02BC:  DATA D7,0F
02BE:  DATA 00,10
02C0:  DATA 2A,10
02C2:  DATA 53,10
02C4:  DATA 7C,10
02C6:  DATA A6,10
02C8:  DATA CF,10
02CA:  DATA F8,10
02CC:  DATA 21,11
02CE:  DATA 4B,11
02D0:  DATA 74,11
02D2:  DATA 9D,11
02D4:  DATA C6,11
02D6:  DATA EF,11
02D8:  DATA 19,12
02DA:  DATA 42,12
02DC:  DATA 6B,12
02DE:  DATA 94,12
02E0:  DATA BD,12
02E2:  DATA E6,12
02E4:  DATA 0F,13
02E6:  DATA 38,13
02E8:  DATA 61,13
02EA:  DATA 8A,13
02EC:  DATA B3,13
02EE:  DATA DC,13
02F0:  DATA 04,14
02F2:  DATA 2D,14
02F4:  DATA 56,14
02F6:  DATA 7F,14
02F8:  DATA A8,14
02FA:  DATA D0,14
02FC:  DATA F9,14
02FE:  DATA 22,15
0300:  DATA 4A,15
0302:  DATA 73,15
0304:  DATA 9C,15
0306:  DATA C4,15
0308:  DATA ED,15
030A:  DATA 15,16
030C:  DATA 3E,16
030E:  DATA 67,16
0310:  DATA 8F,16
0312:  DATA B7,16
0314:  DATA E0,16
0316:  DATA 08,17
0318:  DATA 31,17
031A:  DATA 59,17
031C:  DATA 81,17
031E:  DATA AA,17
0320:  DATA D2,17
0322:  CLRF   FF7
0324:  ADDLW  32
0326:  MOVWF  FF6
0328:  MOVLW  03
032A:  ADDWFC FF7,F
032C:  TBLRD*+
032E:  MOVF   FF5,W
0330:  RETURN 0
0332:  DATA 28,0C
0334:  DATA 01,06
*
0342:  DATA 0D,0A
0344:  DATA 0D,0A
0346:  DATA 43,43
0348:  DATA 53,20
034A:  DATA 43,41
034C:  DATA 4E,20
034E:  DATA 54,52
0350:  DATA 41,4E
0352:  DATA 53,46
0354:  DATA 45,52
0356:  DATA 20,42
0358:  DATA 4D,45
035A:  DATA 32,38
035C:  DATA 30,20
035E:  DATA 44,41
0360:  DATA 54,41
0362:  DATA 0D,0A
0364:  DATA 00,00
0366:  DATA 0D,0A
0368:  DATA 52,75
036A:  DATA 6E,6E
036C:  DATA 69,6E
036E:  DATA 67,2E
0370:  DATA 2E,2E
0372:  DATA 00,00
0374:  DATA 0D,0A
0376:  DATA 53,50
0378:  DATA 49,56
037A:  DATA 41,4C
037C:  DATA 33,20
037E:  DATA 3D,20
0380:  DATA 25,58
0382:  DATA 20,53
0384:  DATA 50,49
0386:  DATA 56,41
0388:  DATA 4C,32
038A:  DATA 20,3D
038C:  DATA 20,25
038E:  DATA 58,20
0390:  DATA 53,50
0392:  DATA 49,56
0394:  DATA 41,4C
0396:  DATA 31,20
0398:  DATA 3D,20
039A:  DATA 25,58
039C:  DATA 20,53
039E:  DATA 50,49
03A0:  DATA 56,41
03A2:  DATA 4C,30
03A4:  DATA 20,3D
03A6:  DATA 20,25
03A8:  DATA 58,20
03AA:  DATA 00,00
03AC:  DATA 0D,50
03AE:  DATA 72,65
03B0:  DATA 20,46
03B2:  DATA 69,6C
03B4:  DATA 74,65
03B6:  DATA 72,20
03B8:  DATA 3D,20
03BA:  DATA 25,66
03BC:  DATA 20,4C
03BE:  DATA 69,6E
03C0:  DATA 65,61
03C2:  DATA 72,69
03C4:  DATA 7A,65
03C6:  DATA 64,20
03C8:  DATA 3D,20
03CA:  DATA 25,66
03CC:  DATA 20,00
03CE:  DATA 49,44
03D0:  DATA 3A,30
03D2:  DATA 78,32
03D4:  DATA 39,00
03D6:  DATA 0D,0A
03D8:  DATA 47,4F
03DA:  DATA 54,3A
03DC:  DATA 20,42
03DE:  DATA 55,46
03E0:  DATA 46,3D
03E2:  DATA 25,55
03E4:  DATA 20,49
03E6:  DATA 44,3D
03E8:  DATA 25,4C
03EA:  DATA 55,20
03EC:  DATA 4C,45
03EE:  DATA 4E,3D
03F0:  DATA 25,55
03F2:  DATA 20,4F
03F4:  DATA 56,46
03F6:  DATA 3D,25
03F8:  DATA 55,20
03FA:  DATA 00,00
03FC:  DATA 46,49
03FE:  DATA 4C,54
0400:  DATA 3D,25
0402:  DATA 55,20
0404:  DATA 52,54
0406:  DATA 52,3D
0408:  DATA 25,55
040A:  DATA 20,45
040C:  DATA 58,54
040E:  DATA 3D,25
0410:  DATA 55,20
0412:  DATA 49,4E
0414:  DATA 56,3D
0416:  DATA 25,55
0418:  DATA 00,00
041A:  DATA 0D,0A
041C:  DATA 20,20
041E:  DATA 20,20
0420:  DATA 44,41
0422:  DATA 54,41
0424:  DATA 20,3D
0426:  DATA 20,00
0428:  DATA 0D,0A
042A:  DATA 46,41
042C:  DATA 49,4C
042E:  DATA 20,6F
0430:  DATA 6E,20
0432:  DATA 47,45
0434:  DATA 54,44
0436:  DATA 0D,0A
0438:  DATA 00,00
043A:  DATA 0D,0A
043C:  DATA 50,55
043E:  DATA 54,20
0440:  DATA 25,55
0442:  DATA 3A,20
0444:  DATA 49,44
0446:  DATA 3D,25
0448:  DATA 4C,55
044A:  DATA 20,4C
044C:  DATA 45,4E
044E:  DATA 3D,25
0450:  DATA 55,20
0452:  DATA 00,00
0454:  DATA 50,52
0456:  DATA 49,3D
0458:  DATA 25,55
045A:  DATA 20,45
045C:  DATA 58,54
045E:  DATA 3D,25
0460:  DATA 55,20
0462:  DATA 52,54
0464:  DATA 52,3D
0466:  DATA 25,55
0468:  DATA 0D,0A
046A:  DATA 20,20
046C:  DATA 20,44
046E:  DATA 41,54
0470:  DATA 41,20
0472:  DATA 3D,20
0474:  DATA 00,00
0476:  DATA 0D,0A
0478:  DATA 46,41
047A:  DATA 49,4C
047C:  DATA 20,6F
047E:  DATA 6E,20
0480:  DATA 50,55
0482:  DATA 54,44
0484:  DATA 0D,0A
0486:  DATA 00,00
0488:  TBLRD*+
048A:  MOVF   FF5,F
048C:  BZ    04A8
048E:  MOVFF  FF6,53
0492:  MOVFF  FF7,54
0496:  MOVF   FF5,W
0498:  BTFSS  F9E.4
049A:  BRA    0498
049C:  MOVWF  FAD
049E:  MOVFF  53,FF6
04A2:  MOVFF  54,FF7
04A6:  BRA    0488
04A8:  RETURN 0
*
08CA:  MOVLW  8E
08CC:  MOVWF  00
08CE:  MOVFF  7B,01
08D2:  MOVFF  7A,02
08D6:  CLRF   03
08D8:  MOVF   01,F
08DA:  BNZ   08EE
08DC:  MOVFF  02,01
08E0:  CLRF   02
08E2:  MOVLW  08
08E4:  SUBWF  00,F
08E6:  MOVF   01,F
08E8:  BNZ   08EE
08EA:  CLRF   00
08EC:  BRA    08FE
08EE:  BCF    FD8.0
08F0:  BTFSC  01.7
08F2:  BRA    08FC
08F4:  RLCF   02,F
08F6:  RLCF   01,F
08F8:  DECF   00,F
08FA:  BRA    08EE
08FC:  BCF    01.7
08FE:  RETURN 0
0900:  TBLRD*+
0902:  MOVFF  FF6,58
0906:  MOVFF  FF7,59
090A:  MOVF   FF5,W
090C:  BTFSS  F9E.4
090E:  BRA    090C
0910:  MOVWF  FAD
0912:  MOVFF  58,FF6
0916:  MOVFF  59,FF7
091A:  DECFSZ 57,F
091C:  BRA    0900
091E:  RETURN 0
0920:  BTFSC  55.7
0922:  BRA    0944
0924:  MOVLW  0F
0926:  MOVWF  00
0928:  SWAPF  54,W
092A:  ANDWF  00,F
092C:  MOVLW  0A
092E:  SUBWF  00,W
0930:  BC    0938
0932:  MOVLW  30
0934:  ADDWF  00,F
0936:  BRA    093C
0938:  MOVF   55,W
093A:  ADDWF  00,F
093C:  MOVF   00,W
093E:  BTFSS  F9E.4
0940:  BRA    093E
0942:  MOVWF  FAD
0944:  MOVLW  0F
0946:  ANDWF  54,F
0948:  MOVLW  0A
094A:  SUBWF  54,W
094C:  BC    0952
094E:  MOVLW  30
0950:  BRA    0956
0952:  BCF    55.7
0954:  MOVF   55,W
0956:  ADDWF  54,F
0958:  MOVF   54,W
095A:  BTFSS  F9E.4
095C:  BRA    095A
095E:  MOVWF  FAD
0960:  RETURN 0
*
09D0:  MOVF   x7A,W
09D2:  BTFSC  FD8.2
09D4:  BRA    0B20
09D6:  MOVWF  x86
09D8:  MOVF   x7E,W
09DA:  BTFSC  FD8.2
09DC:  BRA    0B20
09DE:  SUBWF  x86,F
09E0:  BNC   09EC
09E2:  MOVLW  7F
09E4:  ADDWF  x86,F
09E6:  BTFSC  FD8.0
09E8:  BRA    0B20
09EA:  BRA    09F8
09EC:  MOVLW  81
09EE:  SUBWF  x86,F
09F0:  BTFSS  FD8.0
09F2:  BRA    0B20
09F4:  BTFSC  FD8.2
09F6:  BRA    0B20
09F8:  MOVFF  86,00
09FC:  CLRF   01
09FE:  CLRF   02
0A00:  CLRF   03
0A02:  CLRF   x85
0A04:  MOVFF  7B,84
0A08:  BSF    x84.7
0A0A:  MOVFF  7C,83
0A0E:  MOVFF  7D,82
0A12:  MOVLW  19
0A14:  MOVWF  x86
0A16:  MOVF   x81,W
0A18:  SUBWF  x82,F
0A1A:  BC    0A36
0A1C:  MOVLW  01
0A1E:  SUBWF  x83,F
0A20:  BC    0A36
0A22:  SUBWF  x84,F
0A24:  BC    0A36
0A26:  SUBWF  x85,F
0A28:  BC    0A36
0A2A:  INCF   x85,F
0A2C:  INCF   x84,F
0A2E:  INCF   x83,F
0A30:  MOVF   x81,W
0A32:  ADDWF  x82,F
0A34:  BRA    0A86
0A36:  MOVF   x80,W
0A38:  SUBWF  x83,F
0A3A:  BC    0A60
0A3C:  MOVLW  01
0A3E:  SUBWF  x84,F
0A40:  BC    0A60
0A42:  SUBWF  x85,F
0A44:  BC    0A60
0A46:  INCF   x85,F
0A48:  INCF   x84,F
0A4A:  MOVF   x80,W
0A4C:  ADDWF  x83,F
0A4E:  MOVF   x81,W
0A50:  ADDWF  x82,F
0A52:  BNC   0A86
0A54:  INCF   x83,F
0A56:  BNZ   0A86
0A58:  INCF   x84,F
0A5A:  BNZ   0A86
0A5C:  INCF   x85,F
0A5E:  BRA    0A86
0A60:  MOVF   x7F,W
0A62:  IORLW  80
0A64:  SUBWF  x84,F
0A66:  BC    0A84
0A68:  MOVLW  01
0A6A:  SUBWF  x85,F
0A6C:  BC    0A84
0A6E:  INCF   x85,F
0A70:  MOVF   x7F,W
0A72:  IORLW  80
0A74:  ADDWF  x84,F
0A76:  MOVF   x80,W
0A78:  ADDWF  x83,F
0A7A:  BNC   0A4E
0A7C:  INCF   x84,F
0A7E:  BNZ   0A4E
0A80:  INCF   x85,F
0A82:  BRA    0A4E
0A84:  BSF    03.0
0A86:  DECFSZ x86,F
0A88:  BRA    0A8C
0A8A:  BRA    0AA2
0A8C:  BCF    FD8.0
0A8E:  RLCF   x82,F
0A90:  RLCF   x83,F
0A92:  RLCF   x84,F
0A94:  RLCF   x85,F
0A96:  BCF    FD8.0
0A98:  RLCF   03,F
0A9A:  RLCF   02,F
0A9C:  RLCF   01,F
0A9E:  RLCF   x87,F
0AA0:  BRA    0A16
0AA2:  BTFSS  x87.0
0AA4:  BRA    0AB2
0AA6:  BCF    FD8.0
0AA8:  RRCF   01,F
0AAA:  RRCF   02,F
0AAC:  RRCF   03,F
0AAE:  RRCF   x87,F
0AB0:  BRA    0AB6
0AB2:  DECF   00,F
0AB4:  BZ    0B20
0AB6:  BTFSC  x87.7
0AB8:  BRA    0AF6
0ABA:  BCF    FD8.0
0ABC:  RLCF   x82,F
0ABE:  RLCF   x83,F
0AC0:  RLCF   x84,F
0AC2:  RLCF   x85,F
0AC4:  MOVF   x81,W
0AC6:  SUBWF  x82,F
0AC8:  BC    0AD8
0ACA:  MOVLW  01
0ACC:  SUBWF  x83,F
0ACE:  BC    0AD8
0AD0:  SUBWF  x84,F
0AD2:  BC    0AD8
0AD4:  SUBWF  x85,F
0AD6:  BNC   0B0C
0AD8:  MOVF   x80,W
0ADA:  SUBWF  x83,F
0ADC:  BC    0AE8
0ADE:  MOVLW  01
0AE0:  SUBWF  x84,F
0AE2:  BC    0AE8
0AE4:  SUBWF  x85,F
0AE6:  BNC   0B0C
0AE8:  MOVF   x7F,W
0AEA:  IORLW  80
0AEC:  SUBWF  x84,F
0AEE:  BC    0AF6
0AF0:  MOVLW  01
0AF2:  SUBWF  x85,F
0AF4:  BNC   0B0C
0AF6:  INCF   03,F
0AF8:  BNZ   0B0C
0AFA:  INCF   02,F
0AFC:  BNZ   0B0C
0AFE:  INCF   01,F
0B00:  BNZ   0B0C
0B02:  INCF   00,F
0B04:  BZ    0B20
0B06:  RRCF   01,F
0B08:  RRCF   02,F
0B0A:  RRCF   03,F
0B0C:  MOVFF  7B,86
0B10:  MOVF   x7F,W
0B12:  XORWF  x86,F
0B14:  BTFSS  x86.7
0B16:  BRA    0B1C
0B18:  BSF    01.7
0B1A:  BRA    0B28
0B1C:  BCF    01.7
0B1E:  BRA    0B28
0B20:  CLRF   00
0B22:  CLRF   01
0B24:  CLRF   02
0B26:  CLRF   03
0B28:  RETURN 0
0B2A:  MOVF   x7E,W
0B2C:  BTFSC  FD8.2
0B2E:  BRA    0C12
0B30:  MOVWF  00
0B32:  MOVF   x82,W
0B34:  BTFSC  FD8.2
0B36:  BRA    0C12
0B38:  ADDWF  00,F
0B3A:  BNC   0B44
0B3C:  MOVLW  81
0B3E:  ADDWF  00,F
0B40:  BC    0C12
0B42:  BRA    0B4C
0B44:  MOVLW  7F
0B46:  SUBWF  00,F
0B48:  BNC   0C12
0B4A:  BZ    0C12
0B4C:  MOVFF  7F,86
0B50:  MOVF   x83,W
0B52:  XORWF  x86,F
0B54:  BSF    x7F.7
0B56:  BSF    x83.7
0B58:  MOVF   x81,W
0B5A:  MULWF  x85
0B5C:  MOVFF  FF4,88
0B60:  MOVF   x80,W
0B62:  MULWF  x84
0B64:  MOVFF  FF4,03
0B68:  MOVFF  FF3,87
0B6C:  MULWF  x85
0B6E:  MOVF   FF3,W
0B70:  ADDWF  x88,F
0B72:  MOVF   FF4,W
0B74:  ADDWFC x87,F
0B76:  MOVLW  00
0B78:  ADDWFC 03,F
0B7A:  MOVF   x81,W
0B7C:  MULWF  x84
0B7E:  MOVF   FF3,W
0B80:  ADDWF  x88,F
0B82:  MOVF   FF4,W
0B84:  ADDWFC x87,F
0B86:  MOVLW  00
0B88:  CLRF   02
0B8A:  ADDWFC 03,F
0B8C:  ADDWFC 02,F
0B8E:  MOVF   x7F,W
0B90:  MULWF  x85
0B92:  MOVF   FF3,W
0B94:  ADDWF  x87,F
0B96:  MOVF   FF4,W
0B98:  ADDWFC 03,F
0B9A:  MOVLW  00
0B9C:  ADDWFC 02,F
0B9E:  MOVF   x7F,W
0BA0:  MULWF  x84
0BA2:  MOVF   FF3,W
0BA4:  ADDWF  03,F
0BA6:  MOVF   FF4,W
0BA8:  ADDWFC 02,F
0BAA:  MOVLW  00
0BAC:  CLRF   01
0BAE:  ADDWFC 01,F
0BB0:  MOVF   x81,W
0BB2:  MULWF  x83
0BB4:  MOVF   FF3,W
0BB6:  ADDWF  x87,F
0BB8:  MOVF   FF4,W
0BBA:  ADDWFC 03,F
0BBC:  MOVLW  00
0BBE:  ADDWFC 02,F
0BC0:  ADDWFC 01,F
0BC2:  MOVF   x80,W
0BC4:  MULWF  x83
0BC6:  MOVF   FF3,W
0BC8:  ADDWF  03,F
0BCA:  MOVF   FF4,W
0BCC:  ADDWFC 02,F
0BCE:  MOVLW  00
0BD0:  ADDWFC 01,F
0BD2:  MOVF   x7F,W
0BD4:  MULWF  x83
0BD6:  MOVF   FF3,W
0BD8:  ADDWF  02,F
0BDA:  MOVF   FF4,W
0BDC:  ADDWFC 01,F
0BDE:  INCF   00,F
0BE0:  BTFSC  01.7
0BE2:  BRA    0BEE
0BE4:  RLCF   x87,F
0BE6:  RLCF   03,F
0BE8:  RLCF   02,F
0BEA:  RLCF   01,F
0BEC:  DECF   00,F
0BEE:  MOVLW  00
0BF0:  BTFSS  x87.7
0BF2:  BRA    0C08
0BF4:  INCF   03,F
0BF6:  ADDWFC 02,F
0BF8:  ADDWFC 01,F
0BFA:  MOVF   01,W
0BFC:  BNZ   0C08
0BFE:  MOVF   02,W
0C00:  BNZ   0C08
0C02:  MOVF   03,W
0C04:  BNZ   0C08
0C06:  INCF   00,F
0C08:  BTFSC  x86.7
0C0A:  BSF    01.7
0C0C:  BTFSS  x86.7
0C0E:  BCF    01.7
0C10:  BRA    0C1A
0C12:  CLRF   00
0C14:  CLRF   01
0C16:  CLRF   02
0C18:  CLRF   03
0C1A:  RETURN 0
*
0D1A:  MOVLW  80
0D1C:  BTFSC  FD8.1
0D1E:  XORWF  x7B,F
0D20:  CLRF   x80
0D22:  CLRF   x81
0D24:  MOVFF  77,7F
0D28:  MOVF   x7B,W
0D2A:  XORWF  x7F,F
0D2C:  MOVF   x76,W
0D2E:  BTFSC  FD8.2
0D30:  BRA    0EEA
0D32:  MOVWF  x7E
0D34:  MOVWF  00
0D36:  MOVF   x7A,W
0D38:  BTFSC  FD8.2
0D3A:  BRA    0EFC
0D3C:  SUBWF  x7E,F
0D3E:  BTFSC  FD8.2
0D40:  BRA    0E44
0D42:  BNC   0DBE
0D44:  MOVFF  7B,84
0D48:  BSF    x84.7
0D4A:  MOVFF  7C,83
0D4E:  MOVFF  7D,82
0D52:  CLRF   x81
0D54:  BCF    FD8.0
0D56:  RRCF   x84,F
0D58:  RRCF   x83,F
0D5A:  RRCF   x82,F
0D5C:  RRCF   x81,F
0D5E:  DECFSZ x7E,F
0D60:  BRA    0D52
0D62:  BTFSS  x7F.7
0D64:  BRA    0D6C
0D66:  BSF    x80.0
0D68:  BRA    0F24
0D6A:  BCF    x80.0
0D6C:  BCF    x7E.0
0D6E:  BSF    x80.4
0D70:  CLRF   FEA
0D72:  MOVLW  79
0D74:  MOVWF  FE9
0D76:  BRA    0F4A
0D78:  BCF    x80.4
0D7A:  BTFSC  x7F.7
0D7C:  BRA    0D92
0D7E:  BTFSS  x7E.0
0D80:  BRA    0DA8
0D82:  RRCF   x84,F
0D84:  RRCF   x83,F
0D86:  RRCF   x82,F
0D88:  RRCF   x81,F
0D8A:  INCF   00,F
0D8C:  BTFSC  FD8.2
0D8E:  BRA    0F1A
0D90:  BRA    0DA8
0D92:  BTFSC  x84.7
0D94:  BRA    0DAE
0D96:  BCF    FD8.0
0D98:  RLCF   x81,F
0D9A:  RLCF   x82,F
0D9C:  RLCF   x83,F
0D9E:  RLCF   x84,F
0DA0:  DECF   00,F
0DA2:  BTFSC  FD8.2
0DA4:  BRA    0F1A
0DA6:  BRA    0D92
0DA8:  BSF    x80.6
0DAA:  BRA    0E82
0DAC:  BCF    x80.6
0DAE:  MOVFF  77,7F
0DB2:  BTFSS  x77.7
0DB4:  BRA    0DBA
0DB6:  BSF    x84.7
0DB8:  BRA    0F0C
0DBA:  BCF    x84.7
0DBC:  BRA    0F0C
0DBE:  MOVFF  7A,7E
0DC2:  MOVFF  7A,00
0DC6:  MOVF   x76,W
0DC8:  SUBWF  x7E,F
0DCA:  MOVFF  77,84
0DCE:  BSF    x84.7
0DD0:  MOVFF  78,83
0DD4:  MOVFF  79,82
0DD8:  CLRF   x81
0DDA:  BCF    FD8.0
0DDC:  RRCF   x84,F
0DDE:  RRCF   x83,F
0DE0:  RRCF   x82,F
0DE2:  RRCF   x81,F
0DE4:  DECFSZ x7E,F
0DE6:  BRA    0DD8
0DE8:  BTFSS  x7F.7
0DEA:  BRA    0DF2
0DEC:  BSF    x80.1
0DEE:  BRA    0F24
0DF0:  BCF    x80.1
0DF2:  BCF    x7E.0
0DF4:  BSF    x80.5
0DF6:  CLRF   FEA
0DF8:  MOVLW  7D
0DFA:  MOVWF  FE9
0DFC:  BRA    0F4A
0DFE:  BCF    x80.5
0E00:  BTFSC  x7F.7
0E02:  BRA    0E18
0E04:  BTFSS  x7E.0
0E06:  BRA    0E2E
0E08:  RRCF   x84,F
0E0A:  RRCF   x83,F
0E0C:  RRCF   x82,F
0E0E:  RRCF   x81,F
0E10:  INCF   00,F
0E12:  BTFSC  FD8.2
0E14:  BRA    0F1A
0E16:  BRA    0E2E
0E18:  BTFSC  x84.7
0E1A:  BRA    0E34
0E1C:  BCF    FD8.0
0E1E:  RLCF   x81,F
0E20:  RLCF   x82,F
0E22:  RLCF   x83,F
0E24:  RLCF   x84,F
0E26:  DECF   00,F
0E28:  BTFSC  FD8.2
0E2A:  BRA    0F1A
0E2C:  BRA    0E18
0E2E:  BSF    x80.7
0E30:  BRA    0E82
0E32:  BCF    x80.7
0E34:  MOVFF  7B,7F
0E38:  BTFSS  x7B.7
0E3A:  BRA    0E40
0E3C:  BSF    x84.7
0E3E:  BRA    0F0C
0E40:  BCF    x84.7
0E42:  BRA    0F0C
0E44:  MOVFF  7B,84
0E48:  BSF    x84.7
0E4A:  MOVFF  7C,83
0E4E:  MOVFF  7D,82
0E52:  BTFSS  x7F.7
0E54:  BRA    0E5E
0E56:  BCF    x84.7
0E58:  BSF    x80.2
0E5A:  BRA    0F24
0E5C:  BCF    x80.2
0E5E:  CLRF   x81
0E60:  BCF    x7E.0
0E62:  CLRF   FEA
0E64:  MOVLW  79
0E66:  MOVWF  FE9
0E68:  BRA    0F4A
0E6A:  BTFSC  x7F.7
0E6C:  BRA    0EA6
0E6E:  MOVFF  77,7F
0E72:  BTFSS  x7E.0
0E74:  BRA    0E82
0E76:  RRCF   x84,F
0E78:  RRCF   x83,F
0E7A:  RRCF   x82,F
0E7C:  RRCF   x81,F
0E7E:  INCF   00,F
0E80:  BZ    0F1A
0E82:  BTFSS  x81.7
0E84:  BRA    0E9C
0E86:  INCF   x82,F
0E88:  BNZ   0E9C
0E8A:  INCF   x83,F
0E8C:  BNZ   0E9C
0E8E:  INCF   x84,F
0E90:  BNZ   0E9C
0E92:  RRCF   x84,F
0E94:  RRCF   x83,F
0E96:  RRCF   x82,F
0E98:  INCF   00,F
0E9A:  BZ    0F1A
0E9C:  BTFSC  x80.6
0E9E:  BRA    0DAC
0EA0:  BTFSC  x80.7
0EA2:  BRA    0E32
0EA4:  BRA    0EDE
0EA6:  MOVLW  80
0EA8:  XORWF  x84,F
0EAA:  BTFSS  x84.7
0EAC:  BRA    0EB6
0EAE:  BRA    0F24
0EB0:  MOVFF  7B,7F
0EB4:  BRA    0ECA
0EB6:  MOVFF  77,7F
0EBA:  MOVF   x84,F
0EBC:  BNZ   0ECA
0EBE:  MOVF   x83,F
0EC0:  BNZ   0ECA
0EC2:  MOVF   x82,F
0EC4:  BNZ   0ECA
0EC6:  CLRF   00
0EC8:  BRA    0F0C
0ECA:  BTFSC  x84.7
0ECC:  BRA    0EDE
0ECE:  BCF    FD8.0
0ED0:  RLCF   x81,F
0ED2:  RLCF   x82,F
0ED4:  RLCF   x83,F
0ED6:  RLCF   x84,F
0ED8:  DECFSZ 00,F
0EDA:  BRA    0ECA
0EDC:  BRA    0F1A
0EDE:  BTFSS  x7F.7
0EE0:  BRA    0EE6
0EE2:  BSF    x84.7
0EE4:  BRA    0F0C
0EE6:  BCF    x84.7
0EE8:  BRA    0F0C
0EEA:  MOVFF  7A,00
0EEE:  MOVFF  7B,84
0EF2:  MOVFF  7C,83
0EF6:  MOVFF  7D,82
0EFA:  BRA    0F0C
0EFC:  MOVFF  76,00
0F00:  MOVFF  77,84
0F04:  MOVFF  78,83
0F08:  MOVFF  79,82
0F0C:  MOVFF  84,01
0F10:  MOVFF  83,02
0F14:  MOVFF  82,03
0F18:  BRA    0F82
0F1A:  CLRF   00
0F1C:  CLRF   01
0F1E:  CLRF   02
0F20:  CLRF   03
0F22:  BRA    0F82
0F24:  CLRF   x81
0F26:  COMF   x82,F
0F28:  COMF   x83,F
0F2A:  COMF   x84,F
0F2C:  COMF   x81,F
0F2E:  INCF   x81,F
0F30:  BNZ   0F3C
0F32:  INCF   x82,F
0F34:  BNZ   0F3C
0F36:  INCF   x83,F
0F38:  BNZ   0F3C
0F3A:  INCF   x84,F
0F3C:  BTFSC  x80.0
0F3E:  BRA    0D6A
0F40:  BTFSC  x80.1
0F42:  BRA    0DF0
0F44:  BTFSC  x80.2
0F46:  BRA    0E5C
0F48:  BRA    0EB0
0F4A:  MOVF   FEF,W
0F4C:  ADDWF  x82,F
0F4E:  BNC   0F5A
0F50:  INCF   x83,F
0F52:  BNZ   0F5A
0F54:  INCF   x84,F
0F56:  BTFSC  FD8.2
0F58:  BSF    x7E.0
0F5A:  MOVF   FED,F
0F5C:  MOVF   FEF,W
0F5E:  ADDWF  x83,F
0F60:  BNC   0F68
0F62:  INCF   x84,F
0F64:  BTFSC  FD8.2
0F66:  BSF    x7E.0
0F68:  MOVF   FED,F
0F6A:  MOVF   FEF,W
0F6C:  BTFSC  FEF.7
0F6E:  BRA    0F72
0F70:  XORLW  80
0F72:  ADDWF  x84,F
0F74:  BTFSC  FD8.0
0F76:  BSF    x7E.0
0F78:  BTFSC  x80.4
0F7A:  BRA    0D78
0F7C:  BTFSC  x80.5
0F7E:  BRA    0DFE
0F80:  BRA    0E6A
0F82:  RETURN 0
0F84:  MOVFF  77,7E
0F88:  MOVF   x7B,W
0F8A:  XORWF  x7E,F
0F8C:  BTFSS  x7E.7
0F8E:  BRA    0F9A
0F90:  BCF    FD8.2
0F92:  BCF    FD8.0
0F94:  BTFSC  x77.7
0F96:  BSF    FD8.0
0F98:  BRA    0FF8
0F9A:  MOVFF  77,7E
0F9E:  MOVFF  7A,7F
0FA2:  MOVF   x76,W
0FA4:  SUBWF  x7F,F
0FA6:  BZ    0FB4
0FA8:  BTFSS  x7E.7
0FAA:  BRA    0FF8
0FAC:  MOVF   FD8,W
0FAE:  XORLW  01
0FB0:  MOVWF  FD8
0FB2:  BRA    0FF8
0FB4:  MOVFF  7B,7F
0FB8:  MOVF   x77,W
0FBA:  SUBWF  x7F,F
0FBC:  BZ    0FCA
0FBE:  BTFSS  x7E.7
0FC0:  BRA    0FF8
0FC2:  MOVF   FD8,W
0FC4:  XORLW  01
0FC6:  MOVWF  FD8
0FC8:  BRA    0FF8
0FCA:  MOVFF  7C,7F
0FCE:  MOVF   x78,W
0FD0:  SUBWF  x7F,F
0FD2:  BZ    0FE0
0FD4:  BTFSS  x7E.7
0FD6:  BRA    0FF8
0FD8:  MOVF   FD8,W
0FDA:  XORLW  01
0FDC:  MOVWF  FD8
0FDE:  BRA    0FF8
0FE0:  MOVFF  7D,7F
0FE4:  MOVF   x79,W
0FE6:  SUBWF  x7F,F
0FE8:  BZ    0FF6
0FEA:  BTFSS  x7E.7
0FEC:  BRA    0FF8
0FEE:  MOVF   FD8,W
0FF0:  XORLW  01
0FF2:  MOVWF  FD8
0FF4:  BRA    0FF8
0FF6:  BCF    FD8.0
0FF8:  RETURN 0
*
15CE:  MOVF   x60,W
15D0:  SUBLW  B6
15D2:  MOVWF  x60
15D4:  CLRF   03
15D6:  MOVFF  61,64
15DA:  BSF    x61.7
15DC:  BCF    FD8.0
15DE:  RRCF   x61,F
15E0:  RRCF   x62,F
15E2:  RRCF   x63,F
15E4:  RRCF   03,F
15E6:  RRCF   02,F
15E8:  RRCF   01,F
15EA:  RRCF   00,F
15EC:  DECFSZ x60,F
15EE:  BRA    15DC
15F0:  BTFSS  x64.7
15F2:  BRA    160A
15F4:  COMF   00,F
15F6:  COMF   01,F
15F8:  COMF   02,F
15FA:  COMF   03,F
15FC:  INCF   00,F
15FE:  BTFSC  FD8.2
1600:  INCF   01,F
1602:  BTFSC  FD8.2
1604:  INCF   02,F
1606:  BTFSC  FD8.2
1608:  INCF   03,F
160A:  RETURN 0
160C:  BTFSC  FD8.1
160E:  BRA    1616
1610:  CLRF   FEA
1612:  MOVLW  69
1614:  MOVWF  FE9
1616:  CLRF   00
1618:  CLRF   01
161A:  CLRF   02
161C:  CLRF   03
161E:  CLRF   x69
1620:  CLRF   x6A
1622:  CLRF   x6B
1624:  CLRF   x6C
1626:  MOVF   x68,W
1628:  IORWF  x67,W
162A:  IORWF  x66,W
162C:  IORWF  x65,W
162E:  BZ    1688
1630:  MOVLW  20
1632:  MOVWF  x6D
1634:  BCF    FD8.0
1636:  RLCF   x61,F
1638:  RLCF   x62,F
163A:  RLCF   x63,F
163C:  RLCF   x64,F
163E:  RLCF   x69,F
1640:  RLCF   x6A,F
1642:  RLCF   x6B,F
1644:  RLCF   x6C,F
1646:  MOVF   x68,W
1648:  SUBWF  x6C,W
164A:  BNZ   165C
164C:  MOVF   x67,W
164E:  SUBWF  x6B,W
1650:  BNZ   165C
1652:  MOVF   x66,W
1654:  SUBWF  x6A,W
1656:  BNZ   165C
1658:  MOVF   x65,W
165A:  SUBWF  x69,W
165C:  BNC   167C
165E:  MOVF   x65,W
1660:  SUBWF  x69,F
1662:  MOVF   x66,W
1664:  BTFSS  FD8.0
1666:  INCFSZ x66,W
1668:  SUBWF  x6A,F
166A:  MOVF   x67,W
166C:  BTFSS  FD8.0
166E:  INCFSZ x67,W
1670:  SUBWF  x6B,F
1672:  MOVF   x68,W
1674:  BTFSS  FD8.0
1676:  INCFSZ x68,W
1678:  SUBWF  x6C,F
167A:  BSF    FD8.0
167C:  RLCF   00,F
167E:  RLCF   01,F
1680:  RLCF   02,F
1682:  RLCF   03,F
1684:  DECFSZ x6D,F
1686:  BRA    1634
1688:  MOVFF  69,FEF
168C:  MOVFF  6A,FEC
1690:  MOVFF  6B,FEC
1694:  MOVFF  6C,FEC
1698:  RETURN 0
169A:  MOVF   FE9,W
169C:  MOVWF  58
169E:  MOVF   57,W
16A0:  MOVWF  5A
16A2:  BZ    16D8
16A4:  MOVFF  56,81
16A8:  MOVFF  55,80
16AC:  MOVFF  54,7F
16B0:  MOVFF  53,7E
16B4:  CLRF   x85
16B6:  CLRF   x84
16B8:  MOVLW  20
16BA:  MOVWF  x83
16BC:  MOVLW  82
16BE:  MOVWF  x82
16C0:  CALL   0B2A
16C4:  MOVFF  03,56
16C8:  MOVFF  02,55
16CC:  MOVFF  01,54
16D0:  MOVFF  00,53
16D4:  DECFSZ 5A,F
16D6:  BRA    16A4
16D8:  MOVFF  56,63
16DC:  MOVFF  55,62
16E0:  MOVFF  54,61
16E4:  MOVFF  53,60
16E8:  RCALL  15CE
16EA:  MOVFF  03,56
16EE:  MOVFF  02,55
16F2:  MOVFF  01,54
16F6:  MOVFF  00,53
16FA:  BTFSS  56.7
16FC:  BRA    1718
16FE:  DECF   58,F
1700:  BSF    58.5
1702:  COMF   53,F
1704:  COMF   54,F
1706:  COMF   55,F
1708:  COMF   56,F
170A:  INCF   53,F
170C:  BTFSC  FD8.2
170E:  INCF   54,F
1710:  BTFSC  FD8.2
1712:  INCF   55,F
1714:  BTFSC  FD8.2
1716:  INCF   56,F
1718:  MOVLW  3B
171A:  MOVWF  5F
171C:  MOVLW  9A
171E:  MOVWF  5E
1720:  MOVLW  CA
1722:  MOVWF  5D
1724:  CLRF   5C
1726:  MOVLW  0A
1728:  MOVWF  5A
172A:  MOVF   57,W
172C:  BTFSC  FD8.2
172E:  INCF   58,F
1730:  BSF    FD8.1
1732:  CLRF   FEA
1734:  MOVLW  53
1736:  MOVWF  FE9
1738:  MOVFF  56,64
173C:  MOVFF  55,63
1740:  MOVFF  54,62
1744:  MOVFF  53,61
1748:  MOVFF  5F,68
174C:  MOVFF  5E,67
1750:  MOVFF  5D,66
1754:  MOVFF  5C,65
1758:  RCALL  160C
175A:  MOVF   01,W
175C:  MOVF   00,F
175E:  BNZ   177E
1760:  INCF   57,W
1762:  SUBWF  5A,W
1764:  BZ    177E
1766:  MOVF   58,W
1768:  BZ    1782
176A:  ANDLW  0F
176C:  SUBWF  5A,W
176E:  BZ    1772
1770:  BC    17E8
1772:  BTFSC  58.7
1774:  BRA    17E8
1776:  BTFSC  58.6
1778:  BRA    1782
177A:  MOVLW  20
177C:  BRA    17DE
177E:  MOVLW  20
1780:  ANDWF  58,F
1782:  BTFSS  58.5
1784:  BRA    17A0
1786:  BCF    58.5
1788:  MOVF   57,W
178A:  BTFSS  FD8.2
178C:  DECF   58,F
178E:  MOVF   00,W
1790:  MOVWF  58
1792:  MOVLW  2D
1794:  BTFSS  F9E.4
1796:  BRA    1794
1798:  MOVWF  FAD
179A:  MOVF   58,W
179C:  MOVWF  00
179E:  CLRF   58
17A0:  MOVF   57,W
17A2:  SUBWF  5A,W
17A4:  BNZ   17BC
17A6:  MOVF   00,W
17A8:  MOVWF  58
17AA:  MOVLW  2E
17AC:  BTFSS  F9E.4
17AE:  BRA    17AC
17B0:  MOVWF  FAD
17B2:  MOVF   58,W
17B4:  MOVWF  00
17B6:  MOVLW  20
17B8:  ANDWF  58,F
17BA:  MOVLW  00
17BC:  MOVLW  30
17BE:  BTFSS  58.5
17C0:  BRA    17DE
17C2:  BCF    58.5
17C4:  MOVF   57,W
17C6:  BTFSS  FD8.2
17C8:  DECF   58,F
17CA:  MOVF   00,W
17CC:  MOVWF  58
17CE:  MOVLW  2D
17D0:  BTFSS  F9E.4
17D2:  BRA    17D0
17D4:  MOVWF  FAD
17D6:  MOVF   58,W
17D8:  MOVWF  00
17DA:  CLRF   58
17DC:  MOVLW  30
17DE:  ADDWF  00,F
17E0:  MOVF   00,W
17E2:  BTFSS  F9E.4
17E4:  BRA    17E2
17E6:  MOVWF  FAD
17E8:  BCF    FD8.1
17EA:  MOVFF  5F,64
17EE:  MOVFF  5E,63
17F2:  MOVFF  5D,62
17F6:  MOVFF  5C,61
17FA:  CLRF   x68
17FC:  CLRF   x67
17FE:  CLRF   x66
1800:  MOVLW  0A
1802:  MOVWF  x65
1804:  RCALL  160C
1806:  MOVFF  03,5F
180A:  MOVFF  02,5E
180E:  MOVFF  01,5D
1812:  MOVFF  00,5C
1816:  DECFSZ 5A,F
1818:  BRA    1730
181A:  RETURN 0
*
1856:  ADDWF  FE8,W
1858:  CLRF   FF7
185A:  RLCF   FF7,F
185C:  ADDLW  71
185E:  MOVWF  FF6
1860:  MOVLW  18
1862:  ADDWFC FF7,F
1864:  TBLRD*-
1866:  MOVF   FF5,W
1868:  MOVWF  FFA
186A:  TBLRD*
186C:  MOVF   FF5,W
186E:  MOVWF  FF9
1870:  DATA 2A,18
1872:  DATA 30,18
1874:  DATA 36,18
1876:  DATA 3C,18
*
18C2:  MOVF   FE9,W
18C4:  MOVWF  58
18C6:  MOVF   57,W
18C8:  MOVWF  5A
18CA:  BZ    1900
18CC:  MOVFF  56,81
18D0:  MOVFF  55,80
18D4:  MOVFF  54,7F
18D8:  MOVFF  53,7E
18DC:  CLRF   x85
18DE:  CLRF   x84
18E0:  MOVLW  20
18E2:  MOVWF  x83
18E4:  MOVLW  82
18E6:  MOVWF  x82
18E8:  CALL   0B2A
18EC:  MOVFF  03,56
18F0:  MOVFF  02,55
18F4:  MOVFF  01,54
18F8:  MOVFF  00,53
18FC:  DECFSZ 5A,F
18FE:  BRA    18CC
1900:  MOVFF  56,63
1904:  MOVFF  55,62
1908:  MOVFF  54,61
190C:  MOVFF  53,60
1910:  RCALL  15CE
1912:  MOVFF  03,56
1916:  MOVFF  02,55
191A:  MOVFF  01,54
191E:  MOVFF  00,53
1922:  BTFSS  56.7
1924:  BRA    1940
1926:  DECF   58,F
1928:  BSF    58.5
192A:  COMF   53,F
192C:  COMF   54,F
192E:  COMF   55,F
1930:  COMF   56,F
1932:  INCF   53,F
1934:  BTFSC  FD8.2
1936:  INCF   54,F
1938:  BTFSC  FD8.2
193A:  INCF   55,F
193C:  BTFSC  FD8.2
193E:  INCF   56,F
1940:  MOVLW  3B
1942:  MOVWF  5F
1944:  MOVLW  9A
1946:  MOVWF  5E
1948:  MOVLW  CA
194A:  MOVWF  5D
194C:  CLRF   5C
194E:  MOVLW  0A
1950:  MOVWF  5A
1952:  MOVF   57,W
1954:  BTFSC  FD8.2
1956:  INCF   58,F
1958:  BSF    FD8.1
195A:  CLRF   FEA
195C:  MOVLW  53
195E:  MOVWF  FE9
1960:  MOVFF  56,64
1964:  MOVFF  55,63
1968:  MOVFF  54,62
196C:  MOVFF  53,61
1970:  MOVFF  5F,68
1974:  MOVFF  5E,67
1978:  MOVFF  5D,66
197C:  MOVFF  5C,65
1980:  RCALL  160C
1982:  MOVF   01,W
1984:  MOVF   00,F
1986:  BNZ   19A6
1988:  INCF   57,W
198A:  SUBWF  5A,W
198C:  BZ    19A6
198E:  MOVF   58,W
1990:  BZ    19AA
1992:  ANDLW  0F
1994:  SUBWF  5A,W
1996:  BZ    199A
1998:  BC    1A08
199A:  BTFSC  58.7
199C:  BRA    1A08
199E:  BTFSC  58.6
19A0:  BRA    19AA
19A2:  MOVLW  20
19A4:  BRA    1A00
19A6:  MOVLW  20
19A8:  ANDWF  58,F
19AA:  BTFSS  58.5
19AC:  BRA    19C6
19AE:  BCF    58.5
19B0:  MOVF   57,W
19B2:  BTFSS  FD8.2
19B4:  DECF   58,F
19B6:  MOVF   00,W
19B8:  MOVWF  58
19BA:  MOVLW  2D
19BC:  MOVWF  x60
19BE:  RCALL  1878
19C0:  MOVF   58,W
19C2:  MOVWF  00
19C4:  CLRF   58
19C6:  MOVF   57,W
19C8:  SUBWF  5A,W
19CA:  BNZ   19E0
19CC:  MOVF   00,W
19CE:  MOVWF  58
19D0:  MOVLW  2E
19D2:  MOVWF  x60
19D4:  RCALL  1878
19D6:  MOVF   58,W
19D8:  MOVWF  00
19DA:  MOVLW  20
19DC:  ANDWF  58,F
19DE:  MOVLW  00
19E0:  MOVLW  30
19E2:  BTFSS  58.5
19E4:  BRA    1A00
19E6:  BCF    58.5
19E8:  MOVF   57,W
19EA:  BTFSS  FD8.2
19EC:  DECF   58,F
19EE:  MOVF   00,W
19F0:  MOVWF  58
19F2:  MOVLW  2D
19F4:  MOVWF  x60
19F6:  RCALL  1878
19F8:  MOVF   58,W
19FA:  MOVWF  00
19FC:  CLRF   58
19FE:  MOVLW  30
1A00:  ADDWF  00,F
1A02:  MOVFF  00,60
1A06:  RCALL  1878
1A08:  BCF    FD8.1
1A0A:  MOVFF  5F,64
1A0E:  MOVFF  5E,63
1A12:  MOVFF  5D,62
1A16:  MOVFF  5C,61
1A1A:  CLRF   x68
1A1C:  CLRF   x67
1A1E:  CLRF   x66
1A20:  MOVLW  0A
1A22:  MOVWF  x65
1A24:  RCALL  160C
1A26:  MOVFF  03,5F
1A2A:  MOVFF  02,5E
1A2E:  MOVFF  01,5D
1A32:  MOVFF  00,5C
1A36:  DECFSZ 5A,F
1A38:  BRA    1958
1A3A:  GOTO   2080 (RETURN)
1A3E:  TBLRD*+
1A40:  MOVF   FF5,F
1A42:  BZ    1A5C
1A44:  MOVFF  FF6,53
1A48:  MOVFF  FF7,54
1A4C:  MOVFF  FF5,60
1A50:  RCALL  1878
1A52:  MOVFF  53,FF6
1A56:  MOVFF  54,FF7
1A5A:  BRA    1A3E
1A5C:  GOTO   2096 (RETURN)
*
1C42:  MOVF   5A,W
1C44:  CLRF   01
1C46:  SUBWF  59,W
1C48:  BC    1C50
1C4A:  MOVFF  59,00
1C4E:  BRA    1C68
1C50:  CLRF   00
1C52:  MOVLW  08
1C54:  MOVWF  5B
1C56:  RLCF   59,F
1C58:  RLCF   00,F
1C5A:  MOVF   5A,W
1C5C:  SUBWF  00,W
1C5E:  BTFSC  FD8.0
1C60:  MOVWF  00
1C62:  RLCF   01,F
1C64:  DECFSZ 5B,F
1C66:  BRA    1C56
1C68:  RETURN 0
1C6A:  MOVF   01,W
1C6C:  MOVFF  57,59
1C70:  MOVLW  64
1C72:  MOVWF  5A
1C74:  RCALL  1C42
1C76:  MOVFF  00,57
1C7A:  MOVF   01,W
1C7C:  MOVLW  30
1C7E:  BNZ   1C8E
1C80:  BTFSS  58.1
1C82:  BRA    1C9E
1C84:  BTFSC  58.3
1C86:  BRA    1C9E
1C88:  BTFSC  58.4
1C8A:  MOVLW  20
1C8C:  BRA    1C94
1C8E:  BCF    58.3
1C90:  BCF    58.4
1C92:  BSF    58.0
1C94:  ADDWF  01,F
1C96:  MOVF   01,W
1C98:  BTFSS  F9E.4
1C9A:  BRA    1C98
1C9C:  MOVWF  FAD
1C9E:  MOVFF  57,59
1CA2:  MOVLW  0A
1CA4:  MOVWF  5A
1CA6:  RCALL  1C42
1CA8:  MOVFF  00,57
1CAC:  MOVF   01,W
1CAE:  MOVLW  30
1CB0:  BNZ   1CBE
1CB2:  BTFSC  58.3
1CB4:  BRA    1CC8
1CB6:  BTFSS  58.0
1CB8:  BRA    1CC8
1CBA:  BTFSC  58.4
1CBC:  MOVLW  20
1CBE:  ADDWF  01,F
1CC0:  MOVF   01,W
1CC2:  BTFSS  F9E.4
1CC4:  BRA    1CC2
1CC6:  MOVWF  FAD
1CC8:  MOVLW  30
1CCA:  ADDWF  57,F
1CCC:  MOVF   57,W
1CCE:  BTFSS  F9E.4
1CD0:  BRA    1CCE
1CD2:  MOVWF  FAD
1CD4:  RETURN 0
1CD6:  MOVF   FE9,W
1CD8:  MOVWF  59
1CDA:  MOVLW  3B
1CDC:  MOVWF  x60
1CDE:  MOVLW  9A
1CE0:  MOVWF  5F
1CE2:  MOVLW  CA
1CE4:  MOVWF  5E
1CE6:  CLRF   5D
1CE8:  MOVLW  0A
1CEA:  MOVWF  5B
1CEC:  BSF    FD8.1
1CEE:  CLRF   FEA
1CF0:  MOVLW  55
1CF2:  MOVWF  FE9
1CF4:  MOVFF  58,64
1CF8:  MOVFF  57,63
1CFC:  MOVFF  56,62
1D00:  MOVFF  55,61
1D04:  MOVFF  60,68
1D08:  MOVFF  5F,67
1D0C:  MOVFF  5E,66
1D10:  MOVFF  5D,65
1D14:  RCALL  160C
1D16:  MOVF   01,W
1D18:  MOVF   00,F
1D1A:  BNZ   1D3A
1D1C:  MOVF   5B,W
1D1E:  XORLW  01
1D20:  BZ    1D3A
1D22:  MOVF   59,W
1D24:  BZ    1D3C
1D26:  ANDLW  0F
1D28:  SUBWF  5B,W
1D2A:  BZ    1D2E
1D2C:  BC    1D48
1D2E:  BTFSC  59.7
1D30:  BRA    1D48
1D32:  BTFSC  59.6
1D34:  BRA    1D3C
1D36:  MOVLW  20
1D38:  BRA    1D3E
1D3A:  CLRF   59
1D3C:  MOVLW  30
1D3E:  ADDWF  00,F
1D40:  MOVF   00,W
1D42:  BTFSS  F9E.4
1D44:  BRA    1D42
1D46:  MOVWF  FAD
1D48:  BCF    FD8.1
1D4A:  MOVFF  60,64
1D4E:  MOVFF  5F,63
1D52:  MOVFF  5E,62
1D56:  MOVFF  5D,61
1D5A:  CLRF   x68
1D5C:  CLRF   x67
1D5E:  CLRF   x66
1D60:  MOVLW  0A
1D62:  MOVWF  x65
1D64:  RCALL  160C
1D66:  MOVFF  03,60
1D6A:  MOVFF  02,5F
1D6E:  MOVFF  01,5E
1D72:  MOVFF  00,5D
1D76:  DECFSZ 5B,F
1D78:  BRA    1CEC
1D7A:  RETURN 0
....................  
.................... #list 
....................  
.................... #fuses HS,NOPROTECT,NOLVP,NOWDT 
.................... #use delay(clock=20000000) 
*
04AA:  CLRF   FEA
04AC:  MOVLW  72
04AE:  MOVWF  FE9
04B0:  MOVF   FEF,W
04B2:  BZ    04CE
04B4:  MOVLW  06
04B6:  MOVWF  01
04B8:  CLRF   00
04BA:  DECFSZ 00,F
04BC:  BRA    04BA
04BE:  DECFSZ 01,F
04C0:  BRA    04B8
04C2:  MOVLW  7B
04C4:  MOVWF  00
04C6:  DECFSZ 00,F
04C8:  BRA    04C6
04CA:  DECFSZ FEF,F
04CC:  BRA    04B4
04CE:  RETURN 0
.................... #use rs232(baud=38400, xmit=PIN_C6, rcv=PIN_C7) 
.................... #include <can-18xxx8.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.c                             //// 
.................... //// CAN Library routines for Microchip's PIC18Cxx8 and 18Fxx8 line  //// 
.................... ////                                                                 //// 
.................... //// This library provides the following functions:                  //// 
.................... ////  (for more information on these functions see the comment       //// 
.................... ////   header above each function)                                   //// 
.................... ////                                                                 //// 
.................... ////    can_init - Configures the PIC18xxx8 CAN peripheral           //// 
.................... ////                                                                 //// 
.................... ////    can_set_baud - Sets the baud rate control registers          //// 
.................... ////                                                                 //// 
.................... ////    can_set_mode - Sets the CAN module into a specific mode      //// 
.................... ////                                                                 //// 
.................... ////    can_set_id - Sets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_get_id - Gets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_putd - Sends a message/request with specified ID         //// 
.................... ////                                                                 //// 
.................... ////    can_getd - Returns specified message/request and ID           //// 
.................... ////                                                                 //// 
.................... ////    can_kbhit - Returns true if there is data in one of the      //// 
.................... ////                receive buffers                                  //// 
.................... ////                                                                 //// 
.................... ////    can_tbe - Returns true if the transmit buffer is ready to    //// 
.................... ////              send more data                                     //// 
.................... ////                                                                 //// 
.................... ////    can_abort - Aborts all pending transmissions                 //// 
.................... ////                                                                 //// 
.................... //// PIN_B3 is CANRX, and PIN_B2 is CANTX.  You will need a CAN      //// 
.................... //// transceiver to connect these pins to CANH and CANL bus lines.    //// 
.................... ////                                                                 //// 
.................... //// CCS provides an example, ex_can.c, which shows how to use this  //// 
.................... //// library.                                                        //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History                                                 //// 
.................... ////                                                                 //// 
.................... ////  Jul 27 04 - can_init() uses CAN_USE_EXTENDED_ID instead of     //// 
.................... ////              setting all RX filters to extended.                //// 
.................... ////                                                                 //// 
.................... ////  Feb 24 04 - can_get_id() fixed for EID<18:20>.                 //// 
.................... ////                                                                 //// 
.................... ////  Mar 30 09 - added CANTX2 code for PIC18F6585/8585/6680/8680    //// 
.................... ////                                                                 //// 
.................... ////  May 18 10 - changed variable types to unsigned incase compiled //// 
.................... ////              with #device ANSI, which makes variables signed    //// 
.................... ////                                                                 //// 
.................... ////  Apr 20 11 - updated for new PIC18FxxK80 chips                  //// 
.................... ////                                                                 //// 
.................... ////  Jan 10 13 - updated can_init() function to setup correct tris  //// 
.................... ////              register for PIC being used.                       //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2013 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #include <can-18xxx8.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.h                             //// 
.................... ////                                                                 //// 
.................... //// Prototypes, definitions, defines and macros used for and with   //// 
.................... //// the CCS CAN library for PIC18Fxx8 and PIC18Cxx8.                //// 
.................... ////                                                                 //// 
.................... //// (see can-18xxx8.c)                                              //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2013 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __CCS_CAN18xxx8_LIB_DEFINES__ 
.................... #define __CCS_CAN18xxx8_LIB_DEFINES__ 
....................  
.................... #ifndef CAN_DO_DEBUG 
....................  #define CAN_DO_DEBUG FALSE 
.................... #endif 
....................  
.................... #IFNDEF CAN_USE_EXTENDED_ID 
....................   #define CAN_USE_EXTENDED_ID         TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN_BRG_SYNCH_JUMP_WIDTH 
....................   #define CAN_BRG_SYNCH_JUMP_WIDTH  0  //synchronized jump width (def: 1 x Tq) 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN_BRG_PRESCALAR 
....................   #define CAN_BRG_PRESCALAR  4  //baud rate generator prescalar (def: 4) ( Tq = (2 x (PRE + 1))/Fosc ) 
.................... #ENDIF 
....................  
.................... #ifndef CAN_BRG_SEG_2_PHASE_TS 
....................  #define CAN_BRG_SEG_2_PHASE_TS   TRUE //phase segment 2 time select bit (def: freely programmable) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_SAM 
....................  #define CAN_BRG_SAM 0 //sample of the can bus line (def: bus line is sampled 1 times prior to sample point) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PHASE_SEGMENT_1 
....................  #define CAN_BRG_PHASE_SEGMENT_1  5 //phase segment 1 (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PROPAGATION_TIME 
....................  #define CAN_BRG_PROPAGATION_TIME 2 //propagation time select (def: 3 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_WAKE_FILTER 
....................  #define CAN_BRG_WAKE_FILTER FALSE   //selects can bus line filter for wake up bit 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PHASE_SEGMENT_2 
....................  #define CAN_BRG_PHASE_SEGMENT_2 5 //phase segment 2 time select (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_USE_RX_DOUBLE_BUFFER 
....................  #define CAN_USE_RX_DOUBLE_BUFFER TRUE   //if buffer 0 overflows, do NOT use buffer 1 to put buffer 0 data 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_DRIVE_HIGH 
....................  #define CAN_ENABLE_DRIVE_HIGH 0 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_CAN_CAPTURE 
....................  #define CAN_ENABLE_CAN_CAPTURE 0 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_CANTX2           // added 03/30/09 for PIC18F6585/8585/6680/8680 
....................    #define CAN_ENABLE_CANTX2 0      // 0 CANTX2 disabled, 1 CANTX2 enabled 
.................... #endif 
....................  
.................... #ifndef CAN_CANTX2_SOURCE           // added 03/30/09 for PIC18F6585/8585/6680/8680 
....................    #define CAN_CANTX2_SOURCE 0      // 0 source is invert of CANTX1, 1 source is CAN Clock 
.................... #endif 
....................  
.................... enum CAN_OP_MODE {CAN_OP_CONFIG=4, CAN_OP_LISTEN=3, CAN_OP_LOOPBACK=2, CAN_OP_DISABLE=1, CAN_OP_NORMAL=0}; 
.................... enum CAN_WIN_ADDRESS {CAN_WIN_RX0=0, CAN_WIN_RX1=5, CAN_WIN_TX0=4, CAN_WIN_TX1=3, CAN_WIN_TX2=2}; 
....................  
.................... //can control 
.................... struct { 
....................    int1 void0; //0 
....................    CAN_WIN_ADDRESS win:3;   //1:3 //window address bits 
....................    int1 abat;   //4 //abort all pending transmissions 
....................    CAN_OP_MODE reqop:3;   //5:7   //request can operation mode bits 
.................... } CANCON; 
.................... #byte CANCON = getenv("SFR:CANCON")   //0xF6F 
....................  
....................  
.................... enum CAN_INT_CODE {CAN_INT_WAKEUP=7, CAN_INT_RX0=6, CAN_INT_RX1=5, CAN_INT_TX0=4, CAN_INT_TX1=3, CAN_INT_TX2=2, CAN_INT_ERROR=1, CAN_INT_NO=0}; 
....................  
.................... //can status register READ-ONLY 
.................... struct { 
....................    int1 void0;   //0 
....................    CAN_INT_CODE icode:3;   //1:3   //interrupt code 
....................    int1 void4;   //4 
....................    CAN_OP_MODE opmode:3;   //5:7   //operation mode status 
.................... } CANSTAT; 
.................... #byte CANSTAT = getenv("SFR:CANSTAT")   //0xF6E 
....................  
.................... //communication status register READ-ONLY 
.................... struct { 
....................    int1 ewarn;      //0 //error warning 
....................    int1 rxwarn;      //1 //receiver warning 
....................    int1 txwarn;      //2 //transmitter warning 
....................    int1 rxbp;   //3 //receiver bus passive 
....................    int1 txbp;   //4 //transmitter bus passive bit 
....................    int1 txbo;   //5   //transmitter bus off 
....................    int1 rx1ovfl;   //6   //receive buffer 1 overflow 
....................    int1 rx0ovfl;   //7   //receive buffer 0 overflow 
.................... } COMSTAT; 
.................... #byte COMSTAT= getenv("SFR:COMSTAT") //0xF74 
....................  
.................... //baud rate control register 1 
.................... struct { 
....................    int brp:6;   //0:5   //baud rate prescalar 
....................    int sjw:2;   //6:7   //synchronized jump width 
.................... } BRGCON1; 
.................... #byte BRGCON1 = getenv("SFR:BRGCON1")   //0xF70 
....................  
.................... //baud rate control register 2 
.................... struct { 
....................    int prseg:3; //0:2 //propagation time select 
....................    int seg1ph:3; //3:5 //phase segment 1 
....................    int1 sam; //6 //sample of the can bus line 
....................    int1 seg2phts; //7 //phase segment 2 time select 
.................... } BRGCON2; 
.................... #byte BRGCON2 = getenv("SFR:BRGCON2")   //0xF71 
....................  
.................... //baud rate control register 3 
.................... struct { 
....................    int seg2ph:3;   //0:2   //phase segment 2 time select 
....................    int void543:3;   //3:5 
....................    int1 wakfil;   //6 //selects can bus line filter for wake-up 
....................    int1 void7;   //7 
.................... } BRGCON3; 
.................... #byte BRGCON3 = getenv("SFR:BRGCON3")   //0xF72 
....................  
.................... //can i/o control register 
.................... struct { 
....................    int void3210:4;   //0:3 
....................    int1 cancap;   //4 //can message receive capture 
....................    int1 endrhi;   //5 //enable drive high 
....................    int1 tx2en;    //6   //CANTX2 Pin Enable bit       //added 3/30/09 for PIC18F6585/8585/6680/8680 
....................    int1 tx2src;   //7   //CANTX2 Pin Data Source bit  //added 3/30/09 for PIC18F6585/8585/6680/8680 
.................... } CIOCON; 
.................... #byte CIOCON = getenv("SFR:CIOCON")    //0xF73 
....................  
.................... //transmit buffer n control register 
.................... struct txbNcon_struct { 
....................    int  txpri:2;   //0:1   //transmit priority bits 
....................    int1 void2; //2 
....................    int1 txreq;   //3   //transmit request status (clear to request message abort) 
....................    int1 txerr;   //4   //transmission error detected 
....................    int1 txlarb;   //5   //transmission lost arbitration status 
....................    int1 txabt;   //6   //transmission aborted status 
....................    int1 void7; 
.................... }; 
.................... struct txbNcon_struct TXB0CON; 
.................... struct txbNcon_struct TXB1CON; 
.................... struct txbNcon_struct TXB2CON; 
.................... struct txbNcon_struct TXBaCON; 
.................... #byte   TXB0CON = getenv("SFR:TXB0CON")      //0xF40 
.................... #byte   TXB1CON = getenv("SFR:TXB1CON")      //0xF30 
.................... #byte   TXB2CON = getenv("SFR:TXB2CON")      //0xF20 
.................... #byte TXBaCON =     0xF60             // txbXcon when in the access bank 
....................  
....................  
.................... //transmit buffer n standard identifier 
.................... #byte TXB0SIDH = getenv("SFR:TXB0SIDH")      // 
.................... #byte TXB0SIDL = getenv("SFR:TXB0SIDL")      // 
.................... #byte TXB1SIDH = getenv("SFR:TXB1SIDH")      // 
.................... #byte TXB1SIDL = getenv("SFR:TXB1SIDL")      // 
.................... #byte TXB2SIDH = getenv("SFR:TXB2SIDH")      // 
.................... #byte TXB2SIDL = getenv("SFR:TXB2SIDL")      // 
....................  
.................... //transmit buffer n extended identifier 
.................... #byte TXB0EIDH = getenv("SFR:TXB0EIDH")      //0xF43 
.................... #byte TXB0EIDL = getenv("SFR:TXB0EIDL")      //0xF44 
.................... #byte TXB1EIDH = getenv("SFR:TXB1EIDH")      //0xF33 
.................... #byte TXB1EIDL = getenv("SFR:TXB1EIDL")      //0xF34 
.................... #byte TXB2EIDH = getenv("SFR:TXB2EIDH")      //0xF23 
.................... #byte TXB2EIDL = getenv("SFR:TXB2EIDL")      //0xF24 
....................  
.................... #define RX0MASK      getenv("SFR:RXM0EIDL")     //0xF1B    //rxm0eidl 
.................... #define RX1MASK      getenv("SFR:RXM1EIDL")     //0xF1F    //rxm1eidl 
.................... #define RX0FILTER0   getenv("SFR:RXF0EIDL")     //0xF03    //rxf0eidl 
.................... #define RX0FILTER1   getenv("SFR:RXF1EIDL")     //0xF07    //rxf1eidl 
.................... #define RX1FILTER2   getenv("SFR:RXF2EIDL")     //0xF0B    //rxf2eidl 
.................... #define RX1FILTER3   getenv("SFR:RXF3EIDL")     //0xF0F    //rxf3eidl 
.................... #define RX1FILTER4   getenv("SFR:RXF4EIDL")     //0xF13    //rxf4eidl 
.................... #define RX1FILTER5   getenv("SFR:RXF5EIDL")     //0xF17    //rxf5eidl 
.................... #define RXB0ID       getenv("SFR:RXB0EIDL")     //0xF64    //rxb0eidl 
.................... #define RXB1ID       getenv("SFR:RXB1EIDL")     //0xF54    //rxb1eidl 
.................... #define TXB0ID       getenv("SFR:TXB0EIDL")     //0xF44    //txb0eidl 
.................... #define TXB1ID       getenv("SFR:TXB1EIDL")     //0xF34    //txb1eidl 
.................... #define TXB2ID       getenv("SFR:TXB2EIDL")     //0xF24    //tsb2eidl 
.................... #define TXRXBaID     0xF64 
....................  
.................... //transmit buffer n data byte m 
.................... #byte TXB0D0 = getenv("SFR:TXB0D0")       //0xF46 
.................... #byte TXB0D7 = getenv("SFR:TXB0D7")       //0xF4D 
.................... #byte TXB1D0 = getenv("SFR:TXB1D0")       //0xF36 
.................... #byte TXB1D7 = getenv("SFR:TXB1D7")       //0xF3D 
.................... #byte TXB2D0 = getenv("SFR:TXB2D0")       //0xF26 
.................... #byte TXB2D7 = getenv("SFR:TXB2D7")       //0xF2D 
....................  
.................... //transmit buffer n data length 
.................... struct txbNdlc_struct { 
....................    int dlc:4;   //0:3 
....................    int void54:2; //4:5 
....................    int1 rtr; //6 //transmission frame remote transmission 
....................    int1 void7; //7 
.................... }; 
.................... struct txbNdlc_struct TXB0DLC; 
.................... struct txbNdlc_struct TXB1DLC; 
.................... struct txbNdlc_struct TXB2DLC; 
.................... struct txbNdlc_struct TXBaDLC; 
.................... #byte TXB0DLC = getenv("SFR:TXB0DLC")     //0xF45 
.................... #byte TXB1DLC = getenv("SFR:TXB1DLC")     //0xF35 
.................... #byte TXB2DLC = getenv("SFR:TXB2DLC")     //0xF25 
.................... #byte TXBaDLC = 0xF65  //txbXdlc when in the access bank 
....................  
....................  
.................... //transmit error count register 
.................... #byte TXERRCNT=getenv("SFR:TXERRCNT")     //0xF76 
....................  
....................  
.................... enum CAN_RX_MODE {CAN_RX_ALL=3, CAN_RX_EXT=2, CAN_RX_STD=1, CAN_RX_VALID=0}; 
....................  
.................... //receive buffer 0 control register 
.................... struct { 
....................    int1 filthit0;   //0 //filter hit 
....................    int1 jtoff;   //1 //jump table offset 
....................    int1 rxb0dben;   //2 //receive buffer 0 double buffer enable 
....................    int1 rxrtrro;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receiver buffer mode 
....................    int1 rxful;   //7 //receive full status 
.................... } RXB0CON; 
.................... #byte RXB0CON = getenv("SFR:RXB0CON")     //0xF60 
....................  
.................... //receive buffer 1 control register 
.................... struct { 
....................    int filthit:3;   //0:2 
....................    int1 rxrtrro;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receive buffer mode 
....................    int1 rxful;   //7   //receive full 
.................... } RXB1CON; 
.................... #byte   RXB1CON = getenv("SFR:RXB1CON")     //0xF50 
....................  
....................  
.................... //receive buffer n standard identifier 
.................... #byte   RXB0SIDH = getenv("SFR:RXB0SIDH")    //0xF61 
.................... #byte   RXB0SIDL = getenv("SFR:RXB0SIDL")    //0xF62 
.................... #byte   RXB1SIDH = getenv("SFR:RXB1SIDH")    //0xF51 
.................... #byte   RXB1SIDL = getenv("SFR:RXB1SIDL")    //0xF52 
....................  
.................... //receive buffer n extended identifier 
.................... #byte   RXB0EIDH = getenv("SFR:RXB0EIDH")    //0xF63 
.................... #byte   RXB0EIDL = getenv("SFR:RXB0EIDL")    //0xF64 
.................... #byte   RXB1EIDH = getenv("SFR:RXB1EIDH")    //0xF53 
.................... #byte   RXB1EIDL = getenv("SFR:RXB1EIDL")    //0xF54 
....................  
.................... #byte TXRXBaEIDL=0xF64 
....................  
.................... struct { 
....................    int void012:3; //0:3 
....................    int1 ext;   //extended id 
....................    int1 srr;   //substitute remove request bit 
....................    int void567:3; //5:7 
.................... } TXRXBaSIDL; 
.................... #byte TXRXBaSIDL=0xF62 
....................  
.................... //receive buffer n data length code register 
.................... struct rxbNdlc_struct { 
....................    int dlc:4;   //0:3 //data length code 
....................    int1 rb0; //4 //reserved 
....................    int1 rb1;   //5 //reserved 
....................    int1 rtr;   //6 //receiver remote transmission request bit 
....................    int1 void7;   //7 
.................... }; 
.................... struct rxbNdlc_struct RXB0DLC; 
.................... struct rxbNdlc_struct RXB1DLC; 
.................... struct rxbNdlc_struct RXBaDLC; 
.................... #byte   RXB0DLC = getenv("SFR:RXB0DLC")      //0xF65 
.................... #byte   RXB1DLC = getenv("SFR:RXB1DLC")      //0xF55 
.................... #byte   RXBaDLC = getenv("SFR:RXB0DLC")      //0xF65 
.................... //receive buffer n data field byte m register 
.................... #byte RXB0D0 = getenv("SFR:RXB0D0")    //0xF66 
.................... #byte RXB0D7 = getenv("SFR:RXB0D7")    //0xF6D 
.................... #byte TXRXBaD0=0xF66 
.................... #byte TXRXBaD7=0xF6D 
....................  
.................... //receive error count 
.................... #byte RXERRCNT = getenv("SFR:RXERRCNT")      //0xF75 
....................  
.................... //receive acceptance filter n standard identifier 
.................... #byte RXF0SIDH = getenv("SFR:RXF0SIDH")      //0xF00 
.................... #byte RXF0SIDL = getenv("SFR:RXF0SIDL")      //0xF01 
.................... #byte RXF1SIDH = getenv("SFR:RXF1SIDH")      //0xF04 
.................... #byte RXF1SIDL = getenv("SFR:RXF1SIDL")      //0xF05 
.................... #byte RXF2SIDH = getenv("SFR:RXF2SIDH")      //0xF08 
.................... #byte RXF2SIDL = getenv("SFR:RXF2SIDL")      //0xF09 
.................... #byte RXF3SIDH = getenv("SFR:RXF3SIDH")      //0xF0C 
.................... #byte RXF3SIDL = getenv("SFR:RXF3SIDL")      //0xF0D 
.................... #byte RXF4SIDH = getenv("SFR:RXF4SIDH")      //0xF10 
.................... #byte RXF4SIDL = getenv("SFR:RXF4SIDL")      //0xF11 
.................... #byte RXF5SIDH = getenv("SFR:RXF5SIDH")      //0xF14 
.................... #byte RXF5SIDL = getenv("SFR:RXF5SIDL")      //0xF15 
....................  
.................... //receive acceptance filter n extended identifier 
.................... #byte RXF0EIDH = getenv("SFR:RXF0EIDH")      //0xF02 
.................... #byte RXF0EIDL = getenv("SFR:RXF0EIDL")      //0xF03 
.................... #byte RXF1EIDH = getenv("SFR:RXF1EIDH")      //0xF06 
.................... #byte RXF1EIDL = getenv("SFR:RXF1EIDL")      //0xF07 
.................... #byte RXF2EIDH = getenv("SFR:RXF2EIDH")      //0xF0A 
.................... #byte RXF2EIDL = getenv("SFR:RXF2EIDL")      //0xF0B 
.................... #byte RXF3EIDH = getenv("SFR:RXF3EIDH")      //0xF0E 
.................... #byte RXF3EIDL = getenv("SFR:RXF3EIDL")      //0xF0F 
.................... #byte RXF4EIDH = getenv("SFR:RXF4EIDH")      //0xF12 
.................... #byte RXF4EIDL = getenv("SFR:RXF4EIDL")      //0xF13 
.................... #byte RXF5EIDH = getenv("SFR:RXF5EIDH")      //0xF16 
.................... #byte RXF5EIDL = getenv("SFR:RXF5EIDL")      //0xF17 
....................  
.................... //receive acceptance mask n standard identifier mask 
.................... #byte RXM0SIDH = getenv("SFR:RXM0SIDH")      //0xF18 
.................... #byte RXM0SIDL = getenv("SFR:RXM0SIDL")      //0xF19 
.................... #byte RXM1SIDH = getenv("SFR:RXM1SIDH")      //0xF1C 
.................... #byte RXM1SIDL = getenv("SFR:RXM1SIDL")      //0xF1D 
....................  
.................... //receive acceptance mask n extended identifier mask 
.................... #byte RXM0EIDH = getenv("SFR:RXM0EIDH")      //0xF1A 
.................... #byte RXM0EIDL = getenv("SFR:RXM0EIDL")      //0xF1B 
.................... #byte RXM1EIDH = getenv("SFR:RXM1EIDH")      //0xF1E 
.................... #byte RXM1EIDL = getenv("SFR:RXM1EIDL")      //0xF1F 
....................  
.................... //value to put in mask field to accept all incoming id's 
.................... #define CAN_MASK_ACCEPT_ALL   0 
....................  
.................... //can interrupt flags 
.................... #bit CAN_INT_IRXIF = getenv("BIT:IRXIF")     //0xFA4.7 
.................... #bit CAN_INT_WAKIF = getenv("BIT:WAKIF")     //0xFA4.6 
.................... #bit CAN_INT_ERRIF = getenv("BIT:ERRIF")     //0xFA4.5 
.................... #bit CAN_INT_TXB2IF = getenv("BIT:TXB2IF")   // 0xFA4.4 
.................... #bit CAN_INT_TXB1IF = getenv("BIT:TXB1IF")   // 0xFA4.3 
.................... #bit CAN_INT_TXB0IF = getenv("BIT:TXB0IF")   // 0xFA4.2 
.................... #bit CAN_INT_RXB1IF = getenv("BIT:RXB1IF")   // 0xFA4.1 
.................... #bit CAN_INT_RXB0IF = getenv("BIT:RXB0IF")   // 0xFA4.0 
....................  
.................... //PROTOTYPES 
....................  
.................... struct rx_stat { 
....................    int1 err_ovfl; 
....................    int filthit:3; 
....................    int1 buffer; 
....................    int1 rtr; 
....................    int1 ext; 
....................    int1 inv; 
.................... }; 
....................  
.................... void  can_init(void); 
.................... void  can_set_baud(void); 
.................... void  can_set_mode(CAN_OP_MODE mode); 
.................... void  can_set_id(unsigned int* addr, unsigned int32 id, int1 ext); 
.................... unsigned int32 can_get_id(unsigned int * addr, int1 ext); 
.................... int1  can_putd(unsigned int32 id, unsigned int * data, unsigned int len, unsigned int priority, int1 ext, int1 rtr); 
.................... int1  can_getd(unsigned int32 & id, unsigned int * data, unsigned int & len, struct rx_stat & stat); 
....................  
.................... #endif 
....................  
....................  
.................... #if CAN_DO_DEBUG 
....................  #define can_debug printf 
.................... #else 
....................  #define can_debug 
.................... #endif 
....................  
....................  
.................... //macros 
.................... #define can_kbhit()                 (RXB0CON.rxful || RXB1CON.rxful) 
.................... #define can_tbe()                   (!TXB0CON.txreq || !TXB1CON.txreq || !TXB2CON.txreq) 
.................... #define can_abort()                 (CANCON.abat=1) 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_init() 
.................... // 
.................... // Initializes PIC18xxx8 CAN peripheral.  Sets the RX filter and masks so the 
.................... // CAN peripheral will receive all incoming IDs.  Configures both RX buffers 
.................... // to only accept valid messages (as opposed to all messages, or all 
.................... // extended message, or all standard messages).  Also sets the tri-state 
.................... // setting of B2 to output, and B3 to input (apparently the CAN peripheral 
.................... // doesn't keep track of this) 
.................... // 
.................... // The constants (CAN_USE_RX_DOUBLE_BUFFER, CAN_ENABLE_DRIVE_HIGH, 
.................... // CAN_ENABLE_CAN_CAPTURE) are given a default define in the can-18xxx8.h file. 
.................... // These default values can be overwritten in the main code, but most 
.................... // applications will be fine with these defaults. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... void can_init(void) { 
....................    can_set_mode(CAN_OP_CONFIG);   //must be in config mode before params can be set 
*
0740:  MOVLW  04
0742:  MOVWF  53
0744:  RCALL  05BE
....................    can_set_baud(); 
0746:  BRA    05E0
....................  
....................    RXB0CON=0; 
0748:  CLRF   F60
....................    RXB0CON.rxm=CAN_RX_VALID; 
074A:  MOVLW  9F
074C:  ANDWF  F60,W
074E:  MOVWF  F60
....................    RXB0CON.rxb0dben=CAN_USE_RX_DOUBLE_BUFFER; 
0750:  BSF    F60.2
....................    RXB1CON=RXB0CON; 
0752:  MOVFF  F60,F50
....................  
....................    CIOCON.endrhi=CAN_ENABLE_DRIVE_HIGH; 
0756:  BCF    F73.5
....................    CIOCON.cancap=CAN_ENABLE_CAN_CAPTURE; 
0758:  BCF    F73.4
....................    CIOCON.tx2src=CAN_CANTX2_SOURCE;       //added 3/30/09 for PIC18F6585/8585/6680/8680 
075A:  BCF    F73.7
....................    CIOCON.tx2en=CAN_ENABLE_CANTX2;        //added 3/30/09 for PIC18F6585/8585/6680/8680 
075C:  BCF    F73.6
....................  
....................    can_set_id(RX0MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 0 
075E:  MOVLW  0F
0760:  MOVWF  x64
0762:  MOVLW  1B
0764:  MOVWF  x63
0766:  CLRF   x68
0768:  CLRF   x67
076A:  CLRF   x66
076C:  CLRF   x65
076E:  MOVLW  01
0770:  MOVWF  x69
0772:  RCALL  0610
....................    can_set_id(RX0FILTER0, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 0 
0774:  MOVLW  0F
0776:  MOVWF  x64
0778:  MOVLW  03
077A:  MOVWF  x63
077C:  CLRF   x68
077E:  CLRF   x67
0780:  CLRF   x66
0782:  CLRF   x65
0784:  MOVLW  01
0786:  MOVWF  x69
0788:  RCALL  0610
....................    can_set_id(RX0FILTER1, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 0 
078A:  MOVLW  0F
078C:  MOVWF  x64
078E:  MOVLW  07
0790:  MOVWF  x63
0792:  CLRF   x68
0794:  CLRF   x67
0796:  CLRF   x66
0798:  CLRF   x65
079A:  MOVLW  01
079C:  MOVWF  x69
079E:  RCALL  0610
....................  
....................    can_set_id(RX1MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 1 
07A0:  MOVLW  0F
07A2:  MOVWF  x64
07A4:  MOVLW  1F
07A6:  MOVWF  x63
07A8:  CLRF   x68
07AA:  CLRF   x67
07AC:  CLRF   x66
07AE:  CLRF   x65
07B0:  MOVLW  01
07B2:  MOVWF  x69
07B4:  RCALL  0610
....................    can_set_id(RX1FILTER2, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 1 
07B6:  MOVLW  0F
07B8:  MOVWF  x64
07BA:  MOVLW  0B
07BC:  MOVWF  x63
07BE:  CLRF   x68
07C0:  CLRF   x67
07C2:  CLRF   x66
07C4:  CLRF   x65
07C6:  MOVLW  01
07C8:  MOVWF  x69
07CA:  RCALL  0610
....................    can_set_id(RX1FILTER3, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 1 
07CC:  MOVLW  0F
07CE:  MOVWF  x64
07D0:  MOVWF  x63
07D2:  CLRF   x68
07D4:  CLRF   x67
07D6:  CLRF   x66
07D8:  CLRF   x65
07DA:  MOVLW  01
07DC:  MOVWF  x69
07DE:  RCALL  0610
....................    can_set_id(RX1FILTER4, 0, CAN_USE_EXTENDED_ID);  //set filter 2 of mask 1 
07E0:  MOVLW  0F
07E2:  MOVWF  x64
07E4:  MOVLW  13
07E6:  MOVWF  x63
07E8:  CLRF   x68
07EA:  CLRF   x67
07EC:  CLRF   x66
07EE:  CLRF   x65
07F0:  MOVLW  01
07F2:  MOVWF  x69
07F4:  RCALL  0610
....................    can_set_id(RX1FILTER5, 0, CAN_USE_EXTENDED_ID);  //set filter 3 of mask 1 
07F6:  MOVLW  0F
07F8:  MOVWF  x64
07FA:  MOVLW  17
07FC:  MOVWF  x63
07FE:  CLRF   x68
0800:  CLRF   x67
0802:  CLRF   x66
0804:  CLRF   x65
0806:  MOVLW  01
0808:  MOVWF  x69
080A:  RCALL  0610
....................  
....................   #if (getenv("DEVICE") == "PIC18F6585") || (getenv("DEVICE") == "PIC18LF6585") || \ 
....................       (getenv("DEVICE") == "PIC18F6680") || (getenv("DEVICE") == "PIC18LF6680") || \ 
....................       (getenv("DEVICE") == "PIC18F8585") || (getenv("DEVICE") == "PIC18LF8585") || \ 
....................       (getenv("DEVICE") == "PIC18F8680") || (getenv("DEVICE") == "PIC18LF8680") || \ 
....................       (getenv("DEVICE") == "PIC18C658") || (getenv("DEVICE") == "PIC18C858") 
....................    set_tris_g((*getenv("SFR:TRISG") & 0xFE) | 0x04);  //G2 in, G0 out 
....................    if(CAN_ENABLE_CANTX2) 
....................     bit_clear(*getenv("SFR:TRISG"), 1);  //G1 out 
....................   #elif getenv("FUSE_SET:CANE") 
....................    set_tris_e((*getenv("SFR:TRISE") & 0xDF) | 0x10);  //E4 in, E5 out 
....................   #elif getenv("FUSE_SET:CANC") 
....................    set_tris_c((*getenv("SFR:TRISC") & 0xBF) | 0x80);  //C7 in, C6 out 
....................   #else 
....................    set_tris_b((*getenv("SFR:TRISB") & 0xFB) | 0x08);  //B3 in, B2 out 
080C:  MOVF   F93,W
080E:  ANDLW  FB
0810:  IORLW  08
0812:  MOVWF  F93
....................   #endif 
....................  
....................    can_set_mode(CAN_OP_NORMAL); 
0814:  CLRF   53
0816:  RCALL  05BE
0818:  GOTO   1EE2 (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_baud() 
.................... // 
.................... // Configures the baud rate control registers.  All the defines here 
.................... // are defaulted in the can-18xxx8.h file.  These defaults can, and 
.................... // probably should, be overwritten in the main code. 
.................... // 
.................... // Current defaults are set to work with Microchip's MCP250xxx CAN 
.................... // Developers Kit if this PIC is running at 20Mhz. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_baud(void) { 
....................    BRGCON1.brp=CAN_BRG_PRESCALAR; 
*
05E0:  MOVLW  C0
05E2:  ANDWF  F70,W
05E4:  IORLW  04
05E6:  MOVWF  F70
....................    BRGCON1.sjw=CAN_BRG_SYNCH_JUMP_WIDTH; 
05E8:  MOVLW  3F
05EA:  ANDWF  F70,W
05EC:  MOVWF  F70
....................  
....................    BRGCON2.prseg=CAN_BRG_PROPAGATION_TIME; 
05EE:  MOVLW  F8
05F0:  ANDWF  F71,W
05F2:  IORLW  02
05F4:  MOVWF  F71
....................    BRGCON2.seg1ph=CAN_BRG_PHASE_SEGMENT_1; 
05F6:  MOVLW  C7
05F8:  ANDWF  F71,W
05FA:  IORLW  28
05FC:  MOVWF  F71
....................    BRGCON2.sam=CAN_BRG_SAM; 
05FE:  BCF    F71.6
....................    BRGCON2.seg2phts=CAN_BRG_SEG_2_PHASE_TS; 
0600:  BSF    F71.7
....................  
....................    BRGCON3.seg2ph=CAN_BRG_PHASE_SEGMENT_2; 
0602:  MOVLW  F8
0604:  ANDWF  F72,W
0606:  IORLW  05
0608:  MOVWF  F72
....................    BRGCON3.wakfil=CAN_BRG_WAKE_FILTER; 
060A:  BCF    F72.6
060C:  GOTO   0748 (RETURN)
.................... } 
....................  
.................... void can_set_mode(CAN_OP_MODE mode) { 
....................    CANCON.reqop=mode; 
*
05BE:  SWAPF  53,W
05C0:  ANDLW  70
05C2:  MOVWF  00
05C4:  BCF    FD8.0
05C6:  RLCF   00,F
05C8:  MOVLW  1F
05CA:  ANDWF  F6F,W
05CC:  IORWF  00,W
05CE:  MOVWF  F6F
....................    while( (CANSTAT.opmode) != mode ); 
05D0:  MOVFF  F6E,00
05D4:  SWAPF  00,F
05D6:  RRCF   00,W
05D8:  ANDLW  07
05DA:  SUBWF  53,W
05DC:  BNZ   05D0
05DE:  RETURN 0
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_id() 
.................... // 
.................... // Configures the xxxxEIDL, xxxxEIDH, xxxxSIDL and xxxxSIDH registers to 
.................... // configure the defined buffer to use the specified ID 
.................... // 
.................... //   Parameters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     id - ID to set buffer to 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_id(unsigned int* addr, unsigned int32 id, int1 ext) { 
....................    int *ptr; 
....................  
....................    ptr=addr; 
*
0610:  MOVFF  64,6B
0614:  MOVFF  63,6A
....................  
....................    if (ext) {  //extended 
0618:  MOVF   x69,F
061A:  BZ    06C0
....................       //eidl 
....................       *ptr=make8(id,0); //0:7 
061C:  MOVFF  6A,FE9
0620:  MOVFF  6B,FEA
0624:  MOVFF  65,FEF
....................  
....................       //eidh 
....................       ptr--; 
0628:  MOVF   x6A,W
062A:  BTFSC  FD8.2
062C:  DECF   x6B,F
062E:  DECF   x6A,F
....................       *ptr=make8(id,1); //8:15 
0630:  MOVFF  6A,FE9
0634:  MOVFF  6B,FEA
0638:  MOVFF  66,FEF
....................  
....................       //sidl 
....................       ptr--; 
063C:  MOVF   x6A,W
063E:  BTFSC  FD8.2
0640:  DECF   x6B,F
0642:  DECF   x6A,F
....................       *ptr=make8(id,2) & 0x03;   //16:17 
0644:  MOVFF  6A,FE9
0648:  MOVFF  6B,FEA
064C:  MOVF   x67,W
064E:  ANDLW  03
0650:  MOVWF  FEF
....................       *ptr|=(make8(id,2) << 3) & 0xE0; //18:20 
0652:  MOVFF  6A,FE9
0656:  MOVFF  6B,FEA
065A:  MOVFF  67,00
065E:  RLCF   00,F
0660:  RLCF   00,F
0662:  RLCF   00,F
0664:  MOVLW  F8
0666:  ANDWF  00,F
0668:  MOVF   00,W
066A:  ANDLW  E0
066C:  IORWF  FEF,W
066E:  MOVWF  FEF
....................       *ptr|=0x08; 
0670:  MOVFF  6A,FE9
0674:  MOVFF  6B,FEA
0678:  MOVF   FEF,W
067A:  IORLW  08
067C:  MOVWF  FEF
....................  
....................  
....................       //sidh 
....................       ptr--; 
067E:  MOVF   x6A,W
0680:  BTFSC  FD8.2
0682:  DECF   x6B,F
0684:  DECF   x6A,F
....................       *ptr=((make8(id,2) >> 5) & 0x07 ); //21:23 
0686:  MOVFF  6A,FE9
068A:  MOVFF  6B,FEA
068E:  MOVFF  67,00
0692:  SWAPF  00,F
0694:  RRCF   00,F
0696:  MOVLW  07
0698:  ANDWF  00,F
069A:  MOVF   00,W
069C:  ANDLW  07
069E:  MOVWF  FEF
....................       *ptr|=((make8(id,3) << 3) & 0xF8);//24:28 
06A0:  MOVFF  6A,FE9
06A4:  MOVFF  6B,FEA
06A8:  MOVFF  68,00
06AC:  RLCF   00,F
06AE:  RLCF   00,F
06B0:  RLCF   00,F
06B2:  MOVLW  F8
06B4:  ANDWF  00,F
06B6:  MOVF   00,W
06B8:  ANDLW  F8
06BA:  IORWF  FEF,W
06BC:  MOVWF  FEF
....................    } 
06BE:  BRA    073E
....................    else {   //standard 
....................       //eidl 
....................       *ptr=0; 
06C0:  MOVFF  6A,FE9
06C4:  MOVFF  6B,FEA
06C8:  CLRF   FEF
....................  
....................       //eidh 
....................       ptr--; 
06CA:  MOVF   x6A,W
06CC:  BTFSC  FD8.2
06CE:  DECF   x6B,F
06D0:  DECF   x6A,F
....................       *ptr=0; 
06D2:  MOVFF  6A,FE9
06D6:  MOVFF  6B,FEA
06DA:  CLRF   FEF
....................  
....................       //sidl 
....................       ptr--; 
06DC:  MOVF   x6A,W
06DE:  BTFSC  FD8.2
06E0:  DECF   x6B,F
06E2:  DECF   x6A,F
....................       *ptr=(make8(id,0) << 5) & 0xE0; 
06E4:  MOVFF  6A,FE9
06E8:  MOVFF  6B,FEA
06EC:  MOVFF  65,00
06F0:  SWAPF  00,F
06F2:  RLCF   00,F
06F4:  MOVLW  E0
06F6:  ANDWF  00,F
06F8:  MOVF   00,W
06FA:  ANDLW  E0
06FC:  MOVWF  FEF
....................  
....................       //sidh 
....................       ptr--; 
06FE:  MOVF   x6A,W
0700:  BTFSC  FD8.2
0702:  DECF   x6B,F
0704:  DECF   x6A,F
....................       *ptr=(make8(id,0) >> 3) & 0x1F; 
0706:  MOVFF  6A,FE9
070A:  MOVFF  6B,FEA
070E:  MOVFF  65,00
0712:  RRCF   00,F
0714:  RRCF   00,F
0716:  RRCF   00,F
0718:  MOVLW  1F
071A:  ANDWF  00,F
071C:  MOVF   00,W
071E:  ANDLW  1F
0720:  MOVWF  FEF
....................       *ptr|=(make8(id,1) << 5) & 0xE0; 
0722:  MOVFF  6A,FE9
0726:  MOVFF  6B,FEA
072A:  MOVFF  66,00
072E:  SWAPF  00,F
0730:  RLCF   00,F
0732:  MOVLW  E0
0734:  ANDWF  00,F
0736:  MOVF   00,W
0738:  ANDLW  E0
073A:  IORWF  FEF,W
073C:  MOVWF  FEF
....................    } 
073E:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_get_id() 
.................... // 
.................... // Returns the ID of the specified buffer.  (The opposite of can_set_id()) 
.................... // This is used after receiving a message, to see which ID sent the message. 
.................... // 
.................... //   Parameters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //   Returns: 
.................... //     The ID of the buffer 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... unsigned int32 can_get_id(unsigned int * addr, int1 ext) { 
....................    unsigned int32 ret; 
....................    unsigned int * ptr; 
....................  
....................    ret=0; 
*
1A60:  CLRF   x65
1A62:  CLRF   x64
1A64:  CLRF   x63
1A66:  CLRF   x62
....................    ptr=addr; 
1A68:  MOVFF  60,67
1A6C:  MOVFF  5F,66
....................  
....................    if (ext) { 
1A70:  MOVF   x61,F
1A72:  BTFSC  FD8.2
1A74:  BRA    1B88
....................       ret=*ptr;  //eidl 
1A76:  MOVFF  66,FE9
1A7A:  MOVFF  67,FEA
1A7E:  CLRF   x65
1A80:  CLRF   x64
1A82:  CLRF   x63
1A84:  MOVFF  FEF,62
....................  
....................       ptr--;     //eidh 
1A88:  MOVF   x66,W
1A8A:  BTFSC  FD8.2
1A8C:  DECF   x67,F
1A8E:  DECF   x66,F
....................       ret|=((unsigned int32)*ptr << 8); 
1A90:  MOVFF  66,FE9
1A94:  MOVFF  67,FEA
1A98:  MOVF   FEF,W
1A9A:  CLRF   x6A
1A9C:  CLRF   x69
1A9E:  MOVWF  x68
1AA0:  CLRF   00
1AA2:  MOVF   00,W
1AA4:  IORWF  x62,F
1AA6:  MOVF   x68,W
1AA8:  IORWF  x63,F
1AAA:  MOVF   x69,W
1AAC:  IORWF  x64,F
1AAE:  MOVF   x6A,W
1AB0:  IORWF  x65,F
....................  
....................       ptr--;     //sidl 
1AB2:  MOVF   x66,W
1AB4:  BTFSC  FD8.2
1AB6:  DECF   x67,F
1AB8:  DECF   x66,F
....................       ret|=((unsigned int32)*ptr & 0x03) << 16; 
1ABA:  MOVFF  66,FE9
1ABE:  MOVFF  67,FEA
1AC2:  MOVF   FEF,W
1AC4:  CLRF   x6B
1AC6:  CLRF   x6A
1AC8:  CLRF   x69
1ACA:  MOVWF  x68
1ACC:  MOVLW  03
1ACE:  ANDWF  x68,F
1AD0:  CLRF   x69
1AD2:  CLRF   x6A
1AD4:  CLRF   x6B
1AD6:  CLRF   00
1AD8:  CLRF   01
1ADA:  MOVF   00,W
1ADC:  IORWF  x62,F
1ADE:  MOVF   01,W
1AE0:  IORWF  x63,F
1AE2:  MOVF   x68,W
1AE4:  IORWF  x64,F
1AE6:  MOVF   x69,W
1AE8:  IORWF  x65,F
....................       ret|=((unsigned int32)*ptr & 0xE0) << 13; 
1AEA:  MOVFF  66,FE9
1AEE:  MOVFF  67,FEA
1AF2:  MOVF   FEF,W
1AF4:  CLRF   x6B
1AF6:  CLRF   x6A
1AF8:  CLRF   x69
1AFA:  MOVWF  x68
1AFC:  MOVLW  E0
1AFE:  ANDWF  x68,F
1B00:  CLRF   x69
1B02:  CLRF   x6A
1B04:  CLRF   x6B
1B06:  CLRF   00
1B08:  RLCF   x68,W
1B0A:  MOVWF  01
1B0C:  RLCF   x69,W
1B0E:  MOVWF  02
1B10:  RLCF   x6A,W
1B12:  MOVWF  03
1B14:  RLCF   01,F
1B16:  RLCF   02,F
1B18:  RLCF   03,F
1B1A:  RLCF   01,F
1B1C:  RLCF   02,F
1B1E:  RLCF   03,F
1B20:  RLCF   01,F
1B22:  RLCF   02,F
1B24:  RLCF   03,F
1B26:  RLCF   01,F
1B28:  RLCF   02,F
1B2A:  RLCF   03,F
1B2C:  MOVLW  E0
1B2E:  ANDWF  01,F
1B30:  MOVF   00,W
1B32:  IORWF  x62,F
1B34:  MOVF   01,W
1B36:  IORWF  x63,F
1B38:  MOVF   02,W
1B3A:  IORWF  x64,F
1B3C:  MOVF   03,W
1B3E:  IORWF  x65,F
....................  
....................       ptr--;     //sidh 
1B40:  MOVF   x66,W
1B42:  BTFSC  FD8.2
1B44:  DECF   x67,F
1B46:  DECF   x66,F
....................       ret|=((unsigned int32)*ptr << 21); 
1B48:  MOVFF  66,FE9
1B4C:  MOVFF  67,FEA
1B50:  MOVF   FEF,W
1B52:  CLRF   x69
1B54:  MOVWF  x68
1B56:  CLRF   00
1B58:  CLRF   01
1B5A:  RLCF   x68,W
1B5C:  MOVWF  02
1B5E:  RLCF   x69,W
1B60:  MOVWF  03
1B62:  RLCF   02,F
1B64:  RLCF   03,F
1B66:  RLCF   02,F
1B68:  RLCF   03,F
1B6A:  RLCF   02,F
1B6C:  RLCF   03,F
1B6E:  RLCF   02,F
1B70:  RLCF   03,F
1B72:  MOVLW  E0
1B74:  ANDWF  02,F
1B76:  MOVF   00,W
1B78:  IORWF  x62,F
1B7A:  MOVF   01,W
1B7C:  IORWF  x63,F
1B7E:  MOVF   02,W
1B80:  IORWF  x64,F
1B82:  MOVF   03,W
1B84:  IORWF  x65,F
....................  
....................    } 
1B86:  BRA    1C2E
....................    else { 
....................       ptr-=2;    //sidl 
1B88:  MOVLW  02
1B8A:  SUBWF  x66,F
1B8C:  MOVLW  00
1B8E:  SUBWFB x67,F
....................       ret=((unsigned int32)*ptr & 0xE0) >> 5; 
1B90:  MOVFF  66,FE9
1B94:  MOVFF  67,FEA
1B98:  MOVF   FEF,W
1B9A:  CLRF   x6B
1B9C:  CLRF   x6A
1B9E:  CLRF   x69
1BA0:  MOVWF  x68
1BA2:  MOVLW  E0
1BA4:  ANDWF  x68,F
1BA6:  CLRF   x69
1BA8:  CLRF   x6A
1BAA:  CLRF   x6B
1BAC:  RRCF   x6B,W
1BAE:  MOVWF  x65
1BB0:  RRCF   x6A,W
1BB2:  MOVWF  x64
1BB4:  RRCF   x69,W
1BB6:  MOVWF  x63
1BB8:  RRCF   x68,W
1BBA:  MOVWF  x62
1BBC:  RRCF   x65,F
1BBE:  RRCF   x64,F
1BC0:  RRCF   x63,F
1BC2:  RRCF   x62,F
1BC4:  RRCF   x65,F
1BC6:  RRCF   x64,F
1BC8:  RRCF   x63,F
1BCA:  RRCF   x62,F
1BCC:  RRCF   x65,F
1BCE:  RRCF   x64,F
1BD0:  RRCF   x63,F
1BD2:  RRCF   x62,F
1BD4:  RRCF   x65,F
1BD6:  RRCF   x64,F
1BD8:  RRCF   x63,F
1BDA:  RRCF   x62,F
1BDC:  MOVLW  07
1BDE:  ANDWF  x65,F
....................  
....................       ptr--;     //sidh 
1BE0:  MOVF   x66,W
1BE2:  BTFSC  FD8.2
1BE4:  DECF   x67,F
1BE6:  DECF   x66,F
....................       ret|=((unsigned int32)*ptr << 3); 
1BE8:  MOVFF  66,FE9
1BEC:  MOVFF  67,FEA
1BF0:  MOVF   FEF,W
1BF2:  CLRF   x6B
1BF4:  CLRF   x6A
1BF6:  CLRF   x69
1BF8:  MOVWF  x68
1BFA:  RLCF   x68,W
1BFC:  MOVWF  00
1BFE:  RLCF   x69,W
1C00:  MOVWF  01
1C02:  RLCF   x6A,W
1C04:  MOVWF  02
1C06:  RLCF   x6B,W
1C08:  MOVWF  03
1C0A:  RLCF   00,F
1C0C:  RLCF   01,F
1C0E:  RLCF   02,F
1C10:  RLCF   03,F
1C12:  RLCF   00,F
1C14:  RLCF   01,F
1C16:  RLCF   02,F
1C18:  RLCF   03,F
1C1A:  MOVLW  F8
1C1C:  ANDWF  00,F
1C1E:  MOVF   00,W
1C20:  IORWF  x62,F
1C22:  MOVF   01,W
1C24:  IORWF  x63,F
1C26:  MOVF   02,W
1C28:  IORWF  x64,F
1C2A:  MOVF   03,W
1C2C:  IORWF  x65,F
....................    } 
....................  
....................    return(ret); 
1C2E:  MOVFF  62,00
1C32:  MOVFF  63,01
1C36:  MOVFF  64,02
1C3A:  MOVFF  65,03
1C3E:  GOTO   213A (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_putd() 
.................... // 
.................... // Puts data on a transmit buffer, at which time the CAN peripheral will 
.................... // send when the CAN bus becomes available. 
.................... // 
.................... //    Parameters: 
.................... //       id - ID to transmit data as 
.................... //       data - pointer to data to send 
.................... //       len - length of data to send 
.................... //       priority - priority of message.  The higher the number, the 
.................... //                  sooner the CAN peripheral will send the message. 
.................... //                  Numbers 0 through 3 are valid. 
.................... //       ext - TRUE to use an extended ID, FALSE if not 
.................... //       rtr - TRUE to set the RTR (request) bit in the ID, false if NOT 
.................... // 
.................... //    Returns: 
.................... //       If successful, it will return TRUE 
.................... //       If un-successful, will return FALSE 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_putd(unsigned int32 id, unsigned int * data, unsigned int len, unsigned int priority, int1 ext, int1 rtr) { 
....................    unsigned int i; 
....................    unsigned int * txd0; 
....................    unsigned int port; 
....................  
....................    txd0=&TXRXBaD0; 
*
1D7C:  MOVLW  0F
1D7E:  MOVWF  x61
1D80:  MOVLW  66
1D82:  MOVWF  x60
....................  
....................     // find empty transmitter 
....................     //map access bank addresses to empty transmitter 
....................    if (!TXB0CON.txreq) { 
1D84:  MOVLB  F
1D86:  BTFSC  x40.3
1D88:  BRA    1D9A
....................       CANCON.win=CAN_WIN_TX0; 
1D8A:  MOVLW  F1
1D8C:  ANDWF  F6F,W
1D8E:  IORLW  08
1D90:  MOVWF  F6F
....................       port=0; 
1D92:  MOVLB  0
1D94:  CLRF   x62
....................    } 
1D96:  BRA    1DCE
1D98:  MOVLB  F
....................    else if (!TXB1CON.txreq) { 
1D9A:  BTFSC  x30.3
1D9C:  BRA    1DB0
....................       CANCON.win=CAN_WIN_TX1; 
1D9E:  MOVLW  F1
1DA0:  ANDWF  F6F,W
1DA2:  IORLW  06
1DA4:  MOVWF  F6F
....................       port=1; 
1DA6:  MOVLW  01
1DA8:  MOVLB  0
1DAA:  MOVWF  x62
....................    } 
1DAC:  BRA    1DCE
1DAE:  MOVLB  F
....................    else if (!TXB2CON.txreq) { 
1DB0:  BTFSC  x20.3
1DB2:  BRA    1DC6
....................       CANCON.win=CAN_WIN_TX2; 
1DB4:  MOVLW  F1
1DB6:  ANDWF  F6F,W
1DB8:  IORLW  04
1DBA:  MOVWF  F6F
....................       port=2; 
1DBC:  MOVLW  02
1DBE:  MOVLB  0
1DC0:  MOVWF  x62
....................    } 
1DC2:  BRA    1DCE
1DC4:  MOVLB  F
....................    else { 
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nCAN_PUTD() FAIL: NO OPEN TX BUFFERS\r\n"); 
....................       #endif 
....................       return(0); 
1DC6:  MOVLW  00
1DC8:  MOVWF  01
1DCA:  BRA    1E44
1DCC:  MOVLB  0
....................    } 
....................  
....................    //set priority. 
....................    TXBaCON.txpri=priority; 
1DCE:  MOVF   5C,W
1DD0:  ANDLW  03
1DD2:  MOVWF  00
1DD4:  MOVLW  FC
1DD6:  ANDWF  F60,W
1DD8:  IORWF  00,W
1DDA:  MOVWF  F60
....................  
....................    //set tx mask 
....................    can_set_id(TXRXBaID, id, ext); 
1DDC:  MOVLW  0F
1DDE:  MOVWF  x64
1DE0:  MOVLW  64
1DE2:  MOVWF  x63
1DE4:  MOVFF  58,68
1DE8:  MOVFF  57,67
1DEC:  MOVFF  56,66
1DF0:  MOVFF  55,65
1DF4:  MOVFF  5D,69
1DF8:  CALL   0610
....................  
....................    //set tx data count 
....................    TXBaDLC=len; 
1DFC:  MOVFF  5B,F65
....................    TXBaDLC.rtr=rtr; 
1E00:  BCF    F65.6
1E02:  BTFSC  5E.0
1E04:  BSF    F65.6
....................  
....................     for (i=0; i<len; i++) { 
1E06:  CLRF   5F
1E08:  MOVF   5B,W
1E0A:  SUBWF  5F,W
1E0C:  BC    1E36
....................       *txd0=*data; 
1E0E:  MOVFF  59,FE9
1E12:  MOVFF  5A,FEA
1E16:  MOVFF  FEF,65
1E1A:  MOVFF  61,FEA
1E1E:  MOVFF  60,FE9
1E22:  MOVFF  65,FEF
....................       txd0++; 
1E26:  INCF   x60,F
1E28:  BTFSC  FD8.2
1E2A:  INCF   x61,F
....................       data++; 
1E2C:  INCF   59,F
1E2E:  BTFSC  FD8.2
1E30:  INCF   5A,F
1E32:  INCF   5F,F
1E34:  BRA    1E08
....................     } 
....................  
....................    //enable transmission 
....................    TXBaCON.txreq=1; 
1E36:  BSF    F60.3
....................  
....................    CANCON.win=CAN_WIN_RX0; 
1E38:  MOVLW  F1
1E3A:  ANDWF  F6F,W
1E3C:  MOVWF  F6F
....................  
....................    #if CAN_DO_DEBUG 
....................             can_debug("\r\nCAN_PUTD(): BUFF=%U ID=%LX LEN=%U PRI=%U EXT=%U RTR=%U\r\n", port, id, len, priority, ext, rtr); 
....................             if ((len)&&(!rtr)) { 
....................                data-=len; 
....................                can_debug("  DATA = "); 
....................                for (i=0;i<len;i++) { 
....................                   can_debug("%X ",*data); 
....................                   data++; 
....................                } 
....................                can_debug("\r\n"); 
....................             } 
....................    #endif 
....................  
....................    return(1); 
1E3E:  MOVLW  01
1E40:  MOVWF  01
1E42:  MOVLB  F
1E44:  MOVLB  0
1E46:  GOTO   2382 (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_getd() 
.................... // 
.................... // Gets data from a receive buffer, if the data exists 
.................... // 
.................... //    Returns: 
.................... //      id - ID who sent message 
.................... //      data - pointer to array of data 
.................... //      len - length of received data 
.................... //      stat - structure holding some information (such as which buffer 
.................... //             received it, ext or standard, etc) 
.................... // 
.................... //    Returns: 
.................... //      Function call returns a TRUE if there was data in a RX buffer, FALSE 
.................... //      if there was none. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_getd(unsigned int32 & id, unsigned int * data, unsigned int & len, struct rx_stat & stat) 
.................... { 
....................     unsigned int i; 
....................     unsigned int * ptr; 
....................  
....................     if (RXB0CON.rxful) { 
*
20A8:  BTFSS  F60.7
20AA:  BRA    20DA
....................         CANCON.win=CAN_WIN_RX0; 
20AC:  MOVLW  F1
20AE:  ANDWF  F6F,W
20B0:  MOVWF  F6F
....................         stat.buffer=0; 
20B2:  BCF    25.4
....................  
....................         CAN_INT_RXB0IF=0; 
20B4:  BCF    FA4.0
....................  
....................         stat.err_ovfl=COMSTAT.rx0ovfl; 
20B6:  BCF    25.0
20B8:  BTFSC  F74.7
20BA:  BSF    25.0
....................         COMSTAT.rx0ovfl=0; 
20BC:  BCF    F74.7
....................  
....................         if (RXB0CON.rxb0dben) { 
20BE:  BTFSS  F60.2
20C0:  BRA    20D8
....................          stat.filthit=RXB0CON.filthit0; 
20C2:  MOVLW  00
20C4:  BTFSC  F60.0
20C6:  MOVLW  01
20C8:  ANDLW  07
20CA:  MOVWF  00
20CC:  BCF    FD8.0
20CE:  RLCF   00,F
20D0:  MOVLW  F1
20D2:  ANDWF  25,W
20D4:  IORWF  00,W
20D6:  MOVWF  25
....................         } 
....................     } 
20D8:  BRA    2112
....................     else if ( RXB1CON.rxful ) 
20DA:  MOVLB  F
20DC:  BTFSS  x50.7
20DE:  BRA    210A
....................     { 
....................         CANCON.win=CAN_WIN_RX1; 
20E0:  MOVLW  F1
20E2:  ANDWF  F6F,W
20E4:  IORLW  0A
20E6:  MOVWF  F6F
....................         stat.buffer=1; 
20E8:  BSF    25.4
....................  
....................         CAN_INT_RXB1IF=0; 
20EA:  BCF    FA4.1
....................  
....................         stat.err_ovfl=COMSTAT.rx1ovfl; 
20EC:  BCF    25.0
20EE:  BTFSC  F74.6
20F0:  BSF    25.0
....................         COMSTAT.rx1ovfl=0; 
20F2:  BCF    F74.6
....................  
....................         stat.filthit=RXB1CON.filthit; 
20F4:  MOVF   x50,W
20F6:  ANDLW  07
20F8:  ANDLW  07
20FA:  MOVWF  00
20FC:  BCF    FD8.0
20FE:  RLCF   00,F
2100:  MOVLW  F1
2102:  ANDWF  25,W
2104:  IORWF  00,W
2106:  MOVWF  25
....................     } 
2108:  BRA    2110
....................     else { 
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nFAIL ON CAN_GETD(): NO MESSAGE IN BUFFER\r\n"); 
....................       #endif 
....................       return (0); 
210A:  MOVLW  00
210C:  MOVWF  01
210E:  BRA    21A4
2110:  MOVLB  0
....................     } 
....................  
....................     len = RXBaDLC.dlc; 
2112:  MOVF   F65,W
2114:  ANDLW  0F
2116:  MOVWF  32
....................     stat.rtr=RXBaDLC.rtr; 
2118:  BCF    25.5
211A:  BTFSC  F65.6
211C:  BSF    25.5
....................  
....................     stat.ext=TXRXBaSIDL.ext; 
211E:  BCF    25.6
2120:  BTFSC  F62.3
2122:  BSF    25.6
....................     id=can_get_id(TXRXBaID,stat.ext); 
2124:  MOVLW  00
2126:  BTFSC  25.6
2128:  MOVLW  01
212A:  MOVWF  58
212C:  MOVLW  0F
212E:  MOVWF  x60
2130:  MOVLW  64
2132:  MOVWF  5F
2134:  MOVFF  58,61
2138:  BRA    1A60
213A:  MOVFF  03,29
213E:  MOVFF  02,28
2142:  MOVFF  01,27
2146:  MOVFF  00,26
....................  
....................     ptr = &TXRXBaD0; 
214A:  MOVLW  0F
214C:  MOVWF  57
214E:  MOVLW  66
2150:  MOVWF  56
....................     for ( i = 0; i < len; i++ ) { 
2152:  CLRF   55
2154:  MOVF   32,W
2156:  SUBWF  55,W
2158:  BC    2182
....................         *data = *ptr; 
215A:  MOVFF  56,FE9
215E:  MOVFF  57,FEA
2162:  MOVFF  FEF,5A
2166:  MOVFF  54,FEA
216A:  MOVFF  53,FE9
216E:  MOVFF  5A,FEF
....................         data++; 
2172:  INCF   53,F
2174:  BTFSC  FD8.2
2176:  INCF   54,F
....................         ptr++; 
2178:  INCF   56,F
217A:  BTFSC  FD8.2
217C:  INCF   57,F
217E:  INCF   55,F
2180:  BRA    2154
....................     } 
....................  
....................     // return to default addressing 
....................     CANCON.win=CAN_WIN_RX0; 
2182:  MOVLW  F1
2184:  ANDWF  F6F,W
2186:  MOVWF  F6F
....................  
....................     stat.inv=CAN_INT_IRXIF; 
2188:  BCF    25.7
218A:  BTFSC  FA4.7
218C:  BSF    25.7
....................     CAN_INT_IRXIF = 0; 
218E:  BCF    FA4.7
....................  
....................     if (stat.buffer) { 
2190:  BTFSS  25.4
2192:  BRA    219C
....................       RXB1CON.rxful=0; 
2194:  MOVLB  F
2196:  BCF    x50.7
....................     } 
2198:  BRA    21A0
219A:  MOVLB  0
....................     else { 
....................       RXB0CON.rxful=0; 
219C:  BCF    F60.7
219E:  MOVLB  F
....................     } 
....................  
....................     #if CAN_DO_DEBUG 
....................        can_debug("\r\nCAN_GETD(): BUFF=%U ID=%LX LEN=%U OVF=%U ", stat.buffer, id, len, stat.err_ovfl); 
....................        can_debug("FILT=%U RTR=%U EXT=%U INV=%U", stat.filthit, stat.rtr, stat.ext, stat.inv); 
....................        if ((len)&&(!stat.rtr)) { 
....................           data-=len; 
....................           can_debug("\r\n    DATA = "); 
....................           for (i=0;i<len;i++) { 
....................             can_debug("%X ",*data); 
....................             data++; 
....................           } 
....................        } 
....................        can_debug("\r\n"); 
....................     #endif 
....................  
....................     return(1); 
21A0:  MOVLW  01
21A2:  MOVWF  01
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... #include <MAX31855.c> 
.................... #define SPI_MODE_0  (SPI_L_TO_H | SPI_XMIT_L_TO_H)  
.................... #define SPI_MODE_1  (SPI_L_TO_H)  
.................... #define SPI_MODE_2  (SPI_H_TO_L)  
.................... #define SPI_MODE_3  (SPI_H_TO_L | SPI_XMIT_L_TO_H)  
.................... #define CS PIN_B6 
....................   
.................... //#use spi(MASTER, SPI_MODE_1, DO=PIN_B4, CLK=PIN_B5, BITS = 8, LSB_FIRST, SAMPLE_RISE, baud = 100000, stream=MAX31855)  
.................... //#use spi(SPI1, MASTER, baud=100000, MODE=0, bits=8, stream=MAX31855)  
.................... #use SPI( DI = PIN_B4, CLK = PIN_B5, baud = 100000, BITS = 8, MODE =0, MSB_FIRST, SAMPLE_RISE, stream=MAX31855 ) //  
*
081C:  MOVF   x73,W
081E:  SUBLW  08
0820:  BZ    082A
0822:  MOVWF  x74
0824:  RLCF   x72,F
0826:  DECFSZ x74,F
0828:  BRA    0824
082A:  BSF    F93.4
082C:  BCF    F93.5
082E:  BCF    F8A.5
0830:  MOVFF  73,74
0834:  BSF    F8A.5
0836:  MOVLW  07
0838:  MOVWF  x75
083A:  DECFSZ x75,F
083C:  BRA    083A
083E:  RLCF   01,F
0840:  BTFSS  F81.4
0842:  BCF    01.0
0844:  BTFSC  F81.4
0846:  BSF    01.0
0848:  BCF    F8A.5
084A:  MOVLW  08
084C:  MOVWF  x75
084E:  DECFSZ x75,F
0850:  BRA    084E
0852:  DECFSZ x74,F
0854:  BRA    0834
0856:  RETURN 0
.................... const int16 NegativeK[150]={  0,  39,  79, 118, 157, 197, 236, 275, 314, 353,  
....................                       392, 431, 470, 508, 547, 586, 624, 663, 701, 739,  
....................                       778, 816, 854, 892, 930, 968,1006,1043,1081,1119,  
....................                      1156,1194,1231,1268,1305,1343,1380,1417,1453,1490,  
....................                      1527,1564,1600,1637,1673,1709,1745,1782,1818,1854,  
....................                      1889,1925,1961,1996,2032,2067,2103,2138,2173,2208,  
....................                      2243,2278,2312,2347,2382,2416,2450,2485,2519,2553,  
....................                      2587,2620,2654,2688,2721,2755,2788,2821,2854,2887,  
....................                      2920,2953,2986,3018,3050,3083,3115,3147,3179,3211,  
....................                      3243,3274,3306,3337,3368,3400,3431,3462,3492,3523,  
....................                      3554,3584,3614,3645,3675,3705,3734,3764,3794,3823,  
....................                      3852,3882,3911,3939,3968,3997,4025,4054,4082,4110,  
....................                      4138,4166,4194,4221,4249,4276,4303,4330,4357,4384,  
....................                      4411,4437,4463,4490,4516,4542,4567,4593,4618,4644,  
....................                      4669,4694,4719,4744,4768,4793,4817,4841,4865,4889};  
....................  
.................... const int16 PositiveK[150]={  0,  39,  79, 119, 158, 198, 238, 277, 317, 357,  
....................                       397, 437, 477, 517, 557, 597, 637, 677, 718, 758,  
....................                       798, 838, 879, 919, 960,1000,1041,1081,1122,1163,  
....................                      1203,1244,1285,1326,1366,1407,1448,1489,1530,1571,  
....................                      1612,1653,1694,1735,1776,1817,1858,1899,1941,1982,  
....................                      2023,2064,2106,2147,2188,2230,2271,2312,2354,2395,  
....................                      2436,2478,2519,2561,2602,2644,2685,2727,2768,2810,  
....................                      2851,2893,2934,2976,3017,3059,3100,3142,3184,3225,  
....................                      3267,3308,3350,3391,3433,3474,3516,3557,3599,3640,  
....................                      3682,3723,3765,3806,3848,3889,3931,3972,4013,4055,  
....................                      4096,4138,4179,4220,4262,4303,4344,4385,4427,4468,  
....................                      4509,4550,4591,4633,4674,4715,4756,4797,4838,4879,  
....................                      4920,4961,5002,5043,5084,5124,5165,5206,5247,5288,  
....................                      5328,5369,5410,5450,5491,5532,5572,5613,5653,5694,  
....................                      5735,5775,5815,5856,5896,5937,5977,6017,6058,6098};  
....................  
....................  
.................... static int8 spival[4];  
.................... //int16 Count=0;  
.................... /*******************************************************************************  
.................... //Read SPI data  
.................... *******************************************************************************/   
.................... /* 
.................... void Read4Byte() 
.................... { 
.................... //spi_xfer(); 
....................  
.................... spival[3] = spi_xfer(SPI_1,0); 
.................... spival[2] = spi_xfer(SPI_1,0); 
.................... spival[1] = spi_xfer(SPI_1,0); 
.................... spival[0] = spi_xfer(SPI_1,0); 
....................  
.................... } 
.................... */ 
....................  
.................... void readMAX()  
.................... {  
....................    spi_xfer(MAX31855,0); //switches the stream to mode 2      
0858:  CLRF   x72
085A:  MOVLW  08
085C:  MOVWF  x73
085E:  RCALL  081C
....................    output_low(CS);  
0860:  BCF    F93.6
0862:  BCF    F8A.6
....................    //delay_us(10); 
....................    spival[3]=spi_xfer(MAX31855,0);  
0864:  CLRF   x72
0866:  MOVLW  08
0868:  MOVWF  x73
086A:  RCALL  081C
086C:  MOVF   01,W
086E:  MOVFF  01,1C
....................    delay_us(10); 
0872:  MOVLW  10
0874:  MOVWF  00
0876:  DECFSZ 00,F
0878:  BRA    0876
087A:  NOP   
....................    spival[2]=spi_xfer(MAX31855,0); 
087C:  CLRF   x72
087E:  MOVLW  08
0880:  MOVWF  x73
0882:  RCALL  081C
0884:  MOVF   01,W
0886:  MOVFF  01,1B
....................     delay_us(10); 
088A:  MOVLW  10
088C:  MOVWF  00
088E:  DECFSZ 00,F
0890:  BRA    088E
0892:  NOP   
....................    spival[1]=spi_xfer(MAX31855,0); 
0894:  CLRF   x72
0896:  MOVLW  08
0898:  MOVWF  x73
089A:  RCALL  081C
089C:  MOVF   01,W
089E:  MOVFF  01,1A
....................     delay_us(10); 
08A2:  MOVLW  10
08A4:  MOVWF  00
08A6:  DECFSZ 00,F
08A8:  BRA    08A6
08AA:  NOP   
....................    spival[0]=spi_xfer(MAX31855,0);  
08AC:  CLRF   x72
08AE:  MOVLW  08
08B0:  MOVWF  x73
08B2:  RCALL  081C
08B4:  MOVF   01,W
08B6:  MOVFF  01,19
....................   delay_us(10); 
08BA:  MOVLW  10
08BC:  MOVWF  00
08BE:  DECFSZ 00,F
08C0:  BRA    08BE
08C2:  NOP   
....................    output_high(CS);  
08C4:  BCF    F93.6
08C6:  BSF    F8A.6
08C8:  RETURN 0
.................... }  
....................  
.................... /* 
.................... void readMAX()  
.................... {  
....................       output_low(CS);  
....................       delay_us(10);  
....................       spival[3]=spi_read(0);  
....................       delay_us(10);  
....................       spival[2]=spi_read(0);  
....................       delay_us(10);  
....................       spival[1]=spi_read(0);  
....................       delay_us(10);  
....................       spival[0]=spi_read(0);  
....................       delay_us(10);  
....................       output_high(CS);  
....................  
.................... } 
.................... */ 
.................... /*******************************************************************************  
.................... //Fault detection.  
.................... //Returns >0 if FAULT. If necessary do a bitwise analisys to check fault source  
.................... *******************************************************************************/  
.................... int tempFault()  
*
0962:  BCF    x72.0
0964:  BCF    x72.1
0966:  BCF    x72.2
0968:  BCF    x72.3
.................... {  
....................       int1 Fvdd=0,Fgnd=0,Fopen=0,fault=0;  
....................    
....................       fault=spival[2]&0x01; // pelos menos uma falha  
096A:  MOVF   1B,W
096C:  ANDLW  01
096E:  BCF    x72.3
0970:  BTFSC  FE8.0
0972:  BSF    x72.3
....................       Fvdd=(spival[0]>>2)&0x01;  
0974:  RRCF   19,W
0976:  MOVWF  00
0978:  RRCF   00,F
097A:  MOVLW  3F
097C:  ANDWF  00,F
097E:  MOVF   00,W
0980:  ANDLW  01
0982:  BCF    x72.0
0984:  BTFSC  FE8.0
0986:  BSF    x72.0
....................       Fgnd=(spival[0]>>1)&0x01;  
0988:  BCF    FD8.0
098A:  RRCF   19,W
098C:  ANDLW  01
098E:  BCF    x72.1
0990:  BTFSC  FE8.0
0992:  BSF    x72.1
....................       Fopen=spival[0]&0x01;  
0994:  MOVF   19,W
0996:  ANDLW  01
0998:  BCF    x72.2
099A:  BTFSC  FE8.0
099C:  BSF    x72.2
....................        
....................       return (fault*1+Fvdd*2,Fgnd*4,Fopen*8);  
099E:  MOVLW  00
09A0:  BTFSC  x72.3
09A2:  MOVLW  01
09A4:  MOVWF  x73
09A6:  MOVLW  00
09A8:  BTFSC  x72.0
09AA:  MOVLW  01
09AC:  MOVWF  00
09AE:  BCF    FD8.0
09B0:  RLCF   00,F
09B2:  MOVF   00,W
09B4:  ADDWF  x73,W
09B6:  MOVLW  00
09B8:  BTFSC  x72.1
09BA:  MOVLW  01
09BC:  MULLW  04
09BE:  MOVF   FF3,W
09C0:  MOVLW  00
09C2:  BTFSC  x72.2
09C4:  MOVLW  01
09C6:  MULLW  08
09C8:  MOVFF  FF3,01
09CC:  GOTO   103E (RETURN)
.................... }  
....................  
.................... /*******************************************************************************  
.................... //Read thermocouple temperature  
.................... //Returns returns signed temperature in C approximately  
.................... *******************************************************************************/  
.................... float readExtTemp()  
*
0C1C:  CLRF   x75
0C1E:  CLRF   x74
0C20:  CLRF   x79
0C22:  CLRF   x78
0C24:  CLRF   x77
0C26:  CLRF   x76
.................... {  
....................       int16 temp1=0;  
....................       float aux=0;  
....................    
.................... //spival[3]=0x01;  
.................... //spival[2]=0x90;  
.................... //Count++;  
....................  
....................       temp1=make16(spival[3],spival[2]);  
0C28:  MOVFF  1C,75
0C2C:  MOVFF  1B,74
.................... //temp1-=Count;  
....................  
.................... //fprintf(lcd_putc,"REXT:%LX , ",Temp1);  
....................      
....................       if(!bit_test(temp1,15))  
0C30:  BTFSC  x75.7
0C32:  BRA    0C8A
....................       {  
....................          temp1>>=2;  
0C34:  RRCF   x75,F
0C36:  RRCF   x74,F
0C38:  RRCF   x75,F
0C3A:  RRCF   x74,F
0C3C:  MOVLW  3F
0C3E:  ANDWF  x75,F
.................... //fprintf(lcd_putc,"SR+EXT:%LX , ",Temp1);  
....................          aux=(temp1/4.00);  
0C40:  MOVFF  75,7B
0C44:  MOVFF  74,7A
0C48:  RCALL  08CA
0C4A:  MOVFF  03,7D
0C4E:  MOVFF  02,7C
0C52:  MOVFF  01,7B
0C56:  MOVFF  00,7A
0C5A:  CLRF   x81
0C5C:  CLRF   x80
0C5E:  CLRF   x7F
0C60:  MOVLW  81
0C62:  MOVWF  x7E
0C64:  RCALL  09D0
0C66:  MOVFF  03,79
0C6A:  MOVFF  02,78
0C6E:  MOVFF  01,77
0C72:  MOVFF  00,76
.................... //fprintf(lcd_putc,"Ext+C:%3.2f, ",aux);  
....................             return aux;  
0C76:  MOVFF  76,00
0C7A:  MOVFF  77,01
0C7E:  MOVFF  78,02
0C82:  MOVFF  79,03
0C86:  BRA    0D16
....................       }  
0C88:  BRA    0D16
....................       else  
....................       {  
....................          temp1=~temp1;  
0C8A:  COMF   x74,F
0C8C:  COMF   x75,F
....................          temp1>>=2;  
0C8E:  RRCF   x75,F
0C90:  RRCF   x74,F
0C92:  RRCF   x75,F
0C94:  RRCF   x74,F
0C96:  MOVLW  3F
0C98:  ANDWF  x75,F
....................          temp1+=1;  
0C9A:  MOVLW  01
0C9C:  ADDWF  x74,F
0C9E:  MOVLW  00
0CA0:  ADDWFC x75,F
.................... //fprintf(lcd_putc,"SR-EXT:%LX , ",Temp1);  
....................          aux=((temp1/4.00)*-1.00);  
0CA2:  MOVFF  75,7B
0CA6:  MOVFF  74,7A
0CAA:  RCALL  08CA
0CAC:  MOVFF  03,7D
0CB0:  MOVFF  02,7C
0CB4:  MOVFF  01,7B
0CB8:  MOVFF  00,7A
0CBC:  CLRF   x81
0CBE:  CLRF   x80
0CC0:  CLRF   x7F
0CC2:  MOVLW  81
0CC4:  MOVWF  x7E
0CC6:  RCALL  09D0
0CC8:  MOVFF  03,7D
0CCC:  MOVFF  02,7C
0CD0:  MOVFF  01,7B
0CD4:  MOVFF  00,7A
0CD8:  MOVFF  03,81
0CDC:  MOVFF  02,80
0CE0:  MOVFF  01,7F
0CE4:  MOVFF  00,7E
0CE8:  CLRF   x85
0CEA:  CLRF   x84
0CEC:  MOVLW  80
0CEE:  MOVWF  x83
0CF0:  MOVLW  7F
0CF2:  MOVWF  x82
0CF4:  RCALL  0B2A
0CF6:  MOVFF  03,79
0CFA:  MOVFF  02,78
0CFE:  MOVFF  01,77
0D02:  MOVFF  00,76
....................  
.................... //fprintf(lcd_putc,"RAW Ext-C:%3.2f, ",aux);  
....................             return aux;  
0D06:  MOVFF  76,00
0D0A:  MOVFF  77,01
0D0E:  MOVFF  78,02
0D12:  MOVFF  79,03
....................       }  
0D16:  GOTO   105C (RETURN)
.................... }  
....................  
.................... /*******************************************************************************  
.................... //Read internal temperature  
.................... //Returns returns signed temperature in C approximately  
.................... *******************************************************************************/  
.................... float readIntTemp()  
*
1272:  CLRF   x65
1274:  CLRF   x64
1276:  CLRF   x69
1278:  CLRF   x68
127A:  CLRF   x67
127C:  CLRF   x66
.................... {  
....................     int16 temp2=0;  
....................    float aux=0;  
....................        
....................    temp2=make16(spival[1],spival[0]);  
127E:  MOVFF  1A,65
1282:  MOVFF  19,64
.................... //fprintf(lcd_putc,"RINT:%LX , ",Temp2);  
....................  
....................    if(!bit_test(temp2,15))  
1286:  BTFSC  x65.7
1288:  BRA    12EC
....................    {  
....................       temp2>>=4;  
128A:  RRCF   x65,F
128C:  RRCF   x64,F
128E:  RRCF   x65,F
1290:  RRCF   x64,F
1292:  RRCF   x65,F
1294:  RRCF   x64,F
1296:  RRCF   x65,F
1298:  RRCF   x64,F
129A:  MOVLW  0F
129C:  ANDWF  x65,F
.................... //fprintf(lcd_putc,"SR+INT:%LX , ",Temp2);  
....................       aux=(temp2/16.00);  
129E:  MOVFF  65,7B
12A2:  MOVFF  64,7A
12A6:  CALL   08CA
12AA:  MOVFF  03,7D
12AE:  MOVFF  02,7C
12B2:  MOVFF  01,7B
12B6:  MOVFF  00,7A
12BA:  CLRF   x81
12BC:  CLRF   x80
12BE:  CLRF   x7F
12C0:  MOVLW  83
12C2:  MOVWF  x7E
12C4:  CALL   09D0
12C8:  MOVFF  03,69
12CC:  MOVFF  02,68
12D0:  MOVFF  01,67
12D4:  MOVFF  00,66
.................... //fprintf(lcd_putc,"Int+C:%3.2f\r\n",aux);  
....................          return aux;  
12D8:  MOVFF  66,00
12DC:  MOVFF  67,01
12E0:  MOVFF  68,02
12E4:  MOVFF  69,03
12E8:  BRA    1386
....................     }   
12EA:  BRA    1386
....................    else  
....................    {  
....................       temp2=~temp2;  
12EC:  COMF   x64,F
12EE:  COMF   x65,F
....................       temp2>>=4;  
12F0:  RRCF   x65,F
12F2:  RRCF   x64,F
12F4:  RRCF   x65,F
12F6:  RRCF   x64,F
12F8:  RRCF   x65,F
12FA:  RRCF   x64,F
12FC:  RRCF   x65,F
12FE:  RRCF   x64,F
1300:  MOVLW  0F
1302:  ANDWF  x65,F
....................       temp2+=1;  
1304:  MOVLW  01
1306:  ADDWF  x64,F
1308:  MOVLW  00
130A:  ADDWFC x65,F
.................... //fprintf(lcd_putc,"SR-INT:%LX , ",Temp2);  
....................       aux=((temp2/16.00)*-1.00);  
130C:  MOVFF  65,7B
1310:  MOVFF  64,7A
1314:  CALL   08CA
1318:  MOVFF  03,7D
131C:  MOVFF  02,7C
1320:  MOVFF  01,7B
1324:  MOVFF  00,7A
1328:  CLRF   x81
132A:  CLRF   x80
132C:  CLRF   x7F
132E:  MOVLW  83
1330:  MOVWF  x7E
1332:  CALL   09D0
1336:  MOVFF  03,6D
133A:  MOVFF  02,6C
133E:  MOVFF  01,6B
1342:  MOVFF  00,6A
1346:  MOVFF  03,81
134A:  MOVFF  02,80
134E:  MOVFF  01,7F
1352:  MOVFF  00,7E
1356:  CLRF   x85
1358:  CLRF   x84
135A:  MOVLW  80
135C:  MOVWF  x83
135E:  MOVLW  7F
1360:  MOVWF  x82
1362:  CALL   0B2A
1366:  MOVFF  03,69
136A:  MOVFF  02,68
136E:  MOVFF  01,67
1372:  MOVFF  00,66
.................... //fprintf(lcd_putc,"RAW Int-C:%3.2f\r\n",aux);  
....................          return aux;  
1376:  MOVFF  66,00
137A:  MOVFF  67,01
137E:  MOVFF  68,02
1382:  MOVFF  69,03
....................    }   
1386:  GOTO   13C0 (RETURN)
.................... }  
....................  
.................... float PreFilter()  
*
1012:  CLRF   x70
1014:  BCF    x71.0
.................... {  
.................... float Raw_TC_Temp[3]={0.00,0.00,0.00};  
*
0FFA:  CLRF   x64
0FFC:  CLRF   x65
0FFE:  CLRF   x66
1000:  CLRF   x67
1002:  CLRF   x68
1004:  CLRF   x69
1006:  CLRF   x6A
1008:  CLRF   x6B
100A:  CLRF   x6C
100C:  CLRF   x6D
100E:  CLRF   x6E
1010:  CLRF   x6F
.................... int Raw_Temp_Index=0;  
.................... int1 Temp_Stable=0;  
....................         
....................    while(Temp_Stable==0)  
*
1016:  BTFSC  x71.0
1018:  BRA    11E8
....................    {  
....................       Raw_TC_Temp[0]=0.00;  
101A:  CLRF   x67
101C:  CLRF   x66
101E:  CLRF   x65
1020:  CLRF   x64
....................       Raw_TC_Temp[1]=0.00;  
1022:  CLRF   x6B
1024:  CLRF   x6A
1026:  CLRF   x69
1028:  CLRF   x68
....................       Raw_TC_Temp[2]=0.00;  
102A:  CLRF   x6F
102C:  CLRF   x6E
102E:  CLRF   x6D
1030:  CLRF   x6C
....................       Raw_Temp_Index=0;  
1032:  CLRF   x70
....................  
....................       while(Raw_Temp_Index<3)  
1034:  MOVF   x70,W
1036:  SUBLW  02
1038:  BNC   1080
....................       {  
....................        do{readMAX();}while(tempFault()!=0);  
103A:  RCALL  0858
103C:  BRA    0962
103E:  MOVF   01,F
1040:  BNZ   103A
....................       Raw_TC_Temp[Raw_Temp_Index]=readExtTemp();  
1042:  MOVF   x70,W
1044:  MULLW  04
1046:  MOVF   FF3,W
1048:  CLRF   03
104A:  ADDLW  64
104C:  MOVWF  01
104E:  MOVLW  00
1050:  ADDWFC 03,F
1052:  MOVFF  01,72
1056:  MOVFF  03,73
105A:  BRA    0C1C
105C:  MOVFF  73,FEA
1060:  MOVFF  72,FE9
1064:  MOVFF  00,FEF
1068:  MOVFF  01,FEC
106C:  MOVFF  02,FEC
1070:  MOVFF  03,FEC
.................... //Raw_TC_Temp[Raw_Temp_Index]=-70.00;               // DEBUG  
....................       Raw_Temp_Index++;  
1074:  INCF   x70,F
....................       delay_ms(100);  
1076:  MOVLW  64
1078:  MOVWF  x72
107A:  CALL   04AA
107E:  BRA    1034
....................       }  
....................       if((abs(Raw_TC_Temp[0]-Raw_TC_Temp[1])<1.25)&&(abs(Raw_TC_Temp[1]-Raw_TC_Temp[2])<1.25)&&(abs(Raw_TC_Temp[0]-Raw_TC_Temp[2])<1.25))  
1080:  BSF    FD8.1
1082:  MOVFF  67,79
1086:  MOVFF  66,78
108A:  MOVFF  65,77
108E:  MOVFF  64,76
1092:  MOVFF  6B,7D
1096:  MOVFF  6A,7C
109A:  MOVFF  69,7B
109E:  MOVFF  68,7A
10A2:  RCALL  0D1A
10A4:  MOVFF  03,75
10A8:  MOVFF  02,74
10AC:  MOVFF  01,73
10B0:  MOVFF  00,72
10B4:  MOVFF  00,00
10B8:  MOVFF  01,01
10BC:  MOVFF  02,02
10C0:  MOVFF  03,03
10C4:  BCF    01.7
10C6:  MOVFF  03,75
10CA:  MOVFF  02,74
10CE:  MOVFF  01,73
10D2:  MOVFF  00,72
10D6:  MOVFF  03,79
10DA:  MOVFF  02,78
10DE:  MOVFF  01,77
10E2:  MOVFF  00,76
10E6:  CLRF   x7D
10E8:  CLRF   x7C
10EA:  MOVLW  20
10EC:  MOVWF  x7B
10EE:  MOVLW  7F
10F0:  MOVWF  x7A
10F2:  RCALL  0F84
10F4:  BTFSS  FD8.0
10F6:  BRA    11E6
10F8:  BSF    FD8.1
10FA:  MOVFF  6B,79
10FE:  MOVFF  6A,78
1102:  MOVFF  69,77
1106:  MOVFF  68,76
110A:  MOVFF  6F,7D
110E:  MOVFF  6E,7C
1112:  MOVFF  6D,7B
1116:  MOVFF  6C,7A
111A:  RCALL  0D1A
111C:  MOVFF  03,75
1120:  MOVFF  02,74
1124:  MOVFF  01,73
1128:  MOVFF  00,72
112C:  MOVFF  00,00
1130:  MOVFF  01,01
1134:  MOVFF  02,02
1138:  MOVFF  03,03
113C:  BCF    01.7
113E:  MOVFF  03,75
1142:  MOVFF  02,74
1146:  MOVFF  01,73
114A:  MOVFF  00,72
114E:  MOVFF  03,79
1152:  MOVFF  02,78
1156:  MOVFF  01,77
115A:  MOVFF  00,76
115E:  CLRF   x7D
1160:  CLRF   x7C
1162:  MOVLW  20
1164:  MOVWF  x7B
1166:  MOVLW  7F
1168:  MOVWF  x7A
116A:  RCALL  0F84
116C:  BNC   11E6
116E:  BSF    FD8.1
1170:  MOVFF  67,79
1174:  MOVFF  66,78
1178:  MOVFF  65,77
117C:  MOVFF  64,76
1180:  MOVFF  6F,7D
1184:  MOVFF  6E,7C
1188:  MOVFF  6D,7B
118C:  MOVFF  6C,7A
1190:  RCALL  0D1A
1192:  MOVFF  03,75
1196:  MOVFF  02,74
119A:  MOVFF  01,73
119E:  MOVFF  00,72
11A2:  MOVFF  00,00
11A6:  MOVFF  01,01
11AA:  MOVFF  02,02
11AE:  MOVFF  03,03
11B2:  BCF    01.7
11B4:  MOVFF  03,75
11B8:  MOVFF  02,74
11BC:  MOVFF  01,73
11C0:  MOVFF  00,72
11C4:  MOVFF  03,79
11C8:  MOVFF  02,78
11CC:  MOVFF  01,77
11D0:  MOVFF  00,76
11D4:  CLRF   x7D
11D6:  CLRF   x7C
11D8:  MOVLW  20
11DA:  MOVWF  x7B
11DC:  MOVLW  7F
11DE:  MOVWF  x7A
11E0:  RCALL  0F84
11E2:  BNC   11E6
....................       Temp_Stable=1;  
11E4:  BSF    x71.0
11E6:  BRA    1016
....................    }  
.................... //fprintf(lcd_putc,"RAW1:%3.2f - RAW2:%3.2f - RAW3:%3.2f \r\n",Raw_TC_Temp[0],Raw_TC_Temp[1],Raw_TC_Temp[2]);  
....................    return((Raw_TC_Temp[0]+Raw_TC_Temp[1]+Raw_TC_Temp[2])/3.00);  
11E8:  BCF    FD8.1
11EA:  MOVFF  67,79
11EE:  MOVFF  66,78
11F2:  MOVFF  65,77
11F6:  MOVFF  64,76
11FA:  MOVFF  6B,7D
11FE:  MOVFF  6A,7C
1202:  MOVFF  69,7B
1206:  MOVFF  68,7A
120A:  RCALL  0D1A
120C:  MOVFF  03,75
1210:  MOVFF  02,74
1214:  MOVFF  01,73
1218:  MOVFF  00,72
121C:  BCF    FD8.1
121E:  MOVFF  03,79
1222:  MOVFF  02,78
1226:  MOVFF  01,77
122A:  MOVFF  00,76
122E:  MOVFF  6F,7D
1232:  MOVFF  6E,7C
1236:  MOVFF  6D,7B
123A:  MOVFF  6C,7A
123E:  RCALL  0D1A
1240:  MOVFF  03,75
1244:  MOVFF  02,74
1248:  MOVFF  01,73
124C:  MOVFF  00,72
1250:  MOVFF  03,7D
1254:  MOVFF  02,7C
1258:  MOVFF  01,7B
125C:  MOVFF  00,7A
1260:  CLRF   x81
1262:  CLRF   x80
1264:  MOVLW  40
1266:  MOVWF  x7F
1268:  MOVLW  80
126A:  MOVWF  x7E
126C:  CALL   09D0
1270:  RETURN 0
.................... }  
....................  
.................... float Linearized_TC()  
*
138A:  CLRF   56
138C:  CLRF   55
138E:  CLRF   54
1390:  CLRF   53
1392:  CLRF   5A
1394:  CLRF   59
1396:  CLRF   58
1398:  CLRF   57
139A:  CLRF   5E
139C:  CLRF   5D
139E:  CLRF   5C
13A0:  CLRF   5B
13A2:  CLRF   x62
13A4:  CLRF   x61
13A6:  CLRF   x60
13A8:  CLRF   5F
13AA:  CLRF   x63
.................... {  
....................    const float Curve_Value=0.041276;  
....................    float EXT_Minus_INT=0.00;  
....................    float TC_Voltage=0.00;  
....................    float INT_Temp=0.00;  
....................    float EXT_Temp=0.00;  
....................    int NIST_Index=0;  
....................  
....................      
....................    EXT_Temp=PreFilter();  
13AC:  RCALL  0FFA
13AE:  MOVFF  03,62
13B2:  MOVFF  02,61
13B6:  MOVFF  01,60
13BA:  MOVFF  00,5F
....................    INT_Temp=readIntTemp();  
13BE:  BRA    1272
13C0:  MOVFF  03,5E
13C4:  MOVFF  02,5D
13C8:  MOVFF  01,5C
13CC:  MOVFF  00,5B
....................  
....................    if(EXT_Temp<0.00)  
13D0:  MOVFF  62,79
13D4:  MOVFF  61,78
13D8:  MOVFF  60,77
13DC:  MOVFF  5F,76
13E0:  CLRF   x7D
13E2:  CLRF   x7C
13E4:  CLRF   x7B
13E6:  CLRF   x7A
13E8:  RCALL  0F84
13EA:  BTFSS  FD8.0
13EC:  BRA    15BA
....................    {  
....................       EXT_Minus_INT=(EXT_Temp-INT_Temp);  
13EE:  BSF    FD8.1
13F0:  MOVFF  62,79
13F4:  MOVFF  61,78
13F8:  MOVFF  60,77
13FC:  MOVFF  5F,76
1400:  MOVFF  5E,7D
1404:  MOVFF  5D,7C
1408:  MOVFF  5C,7B
140C:  MOVFF  5B,7A
1410:  RCALL  0D1A
1412:  MOVFF  03,56
1416:  MOVFF  02,55
141A:  MOVFF  01,54
141E:  MOVFF  00,53
....................       TC_Voltage=EXT_Minus_INT*Curve_Value;  
1422:  MOVFF  56,81
1426:  MOVFF  55,80
142A:  MOVFF  54,7F
142E:  MOVFF  53,7E
1432:  MOVLW  06
1434:  MOVWF  x85
1436:  MOVLW  11
1438:  MOVWF  x84
143A:  MOVLW  29
143C:  MOVWF  x83
143E:  MOVLW  7A
1440:  MOVWF  x82
1442:  CALL   0B2A
1446:  MOVFF  03,5A
144A:  MOVFF  02,59
144E:  MOVFF  01,58
1452:  MOVFF  00,57
.................... //fprintf(lcd_putc,"TC_Voltage:%3.2f\r\n",TC_Voltage);   //MATH OK  
....................  
.................... //fprintf(lcd_putc,"DEC_INT:%3.2f\r\n",INT_Temp);     
....................       while(NIST_Index<INT_Temp)NIST_Index++;  
1456:  CLRF   x7B
1458:  MOVFF  63,7A
145C:  CALL   08CA
1460:  MOVFF  03,79
1464:  MOVFF  02,78
1468:  MOVFF  01,77
146C:  MOVFF  00,76
1470:  MOVFF  5E,7D
1474:  MOVFF  5D,7C
1478:  MOVFF  5C,7B
147C:  MOVFF  5B,7A
1480:  RCALL  0F84
1482:  BNC   1488
1484:  INCF   x63,F
1486:  BRA    1456
....................       NIST_Index--;  
1488:  DECF   x63,F
....................  
.................... //fprintf(lcd_putc,"NIST:%d\r\n",NIST_Index);     
.................... //fprintf(lcd_putc,"NIST MV:%ld\r\n",PositiveK[NIST_Index]);     
....................       TC_Voltage+=(PositiveK[NIST_Index]/1000.00);  
148A:  CLRF   03
148C:  MOVFF  63,02
1490:  BCF    FD8.0
1492:  RLCF   02,F
1494:  RLCF   03,F
1496:  MOVF   02,W
1498:  MOVFF  03,FF7
149C:  CALL   01E8
14A0:  TBLRD*+
14A2:  MOVFF  FF5,03
14A6:  MOVWF  x64
14A8:  MOVFF  03,65
14AC:  MOVFF  03,7B
14B0:  MOVWF  x7A
14B2:  CALL   08CA
14B6:  MOVFF  03,7D
14BA:  MOVFF  02,7C
14BE:  MOVFF  01,7B
14C2:  MOVFF  00,7A
14C6:  CLRF   x81
14C8:  CLRF   x80
14CA:  MOVLW  7A
14CC:  MOVWF  x7F
14CE:  MOVLW  88
14D0:  MOVWF  x7E
14D2:  CALL   09D0
14D6:  BCF    FD8.1
14D8:  MOVFF  5A,79
14DC:  MOVFF  59,78
14E0:  MOVFF  58,77
14E4:  MOVFF  57,76
14E8:  MOVFF  03,7D
14EC:  MOVFF  02,7C
14F0:  MOVFF  01,7B
14F4:  MOVFF  00,7A
14F8:  RCALL  0D1A
14FA:  MOVFF  03,5A
14FE:  MOVFF  02,59
1502:  MOVFF  01,58
1506:  MOVFF  00,57
....................       TC_Voltage*=-1000.00;     
150A:  MOVFF  5A,81
150E:  MOVFF  59,80
1512:  MOVFF  58,7F
1516:  MOVFF  57,7E
151A:  CLRF   x85
151C:  CLRF   x84
151E:  MOVLW  FA
1520:  MOVWF  x83
1522:  MOVLW  88
1524:  MOVWF  x82
1526:  CALL   0B2A
152A:  MOVFF  03,5A
152E:  MOVFF  02,59
1532:  MOVFF  01,58
1536:  MOVFF  00,57
.................... //fprintf(lcd_putc,"TC_Voltage2:%3.2f\r\n",TC_Voltage);  
....................      
....................       NIST_Index=0;  
153A:  CLRF   x63
....................       while(TC_Voltage>NegativeK[NIST_Index])  
153C:  CLRF   03
153E:  MOVFF  63,02
1542:  BCF    FD8.0
1544:  RLCF   02,F
1546:  RLCF   03,F
1548:  MOVF   02,W
154A:  MOVFF  03,FF7
154E:  CALL   00AE
1552:  TBLRD*+
1554:  MOVFF  FF5,03
1558:  MOVWF  x7A
155A:  MOVFF  03,7B
155E:  CALL   08CA
1562:  MOVFF  03,79
1566:  MOVFF  02,78
156A:  MOVFF  01,77
156E:  MOVFF  00,76
1572:  MOVFF  5A,7D
1576:  MOVFF  59,7C
157A:  MOVFF  58,7B
157E:  MOVFF  57,7A
1582:  RCALL  0F84
1584:  BNC   158A
....................       {  
....................          NIST_Index++;  
1586:  INCF   x63,F
1588:  BRA    153C
....................       }  
....................       NIST_Index--;  
158A:  DECF   x63,F
.................... //fprintf(lcd_putc,"EXT NIST:%d\r\n",NIST_Index);     
....................       return(NIST_Index*-1.00);  
158C:  CLRF   x7B
158E:  MOVFF  63,7A
1592:  CALL   08CA
1596:  MOVFF  03,81
159A:  MOVFF  02,80
159E:  MOVFF  01,7F
15A2:  MOVFF  00,7E
15A6:  CLRF   x85
15A8:  CLRF   x84
15AA:  MOVLW  80
15AC:  MOVWF  x83
15AE:  MOVLW  7F
15B0:  MOVWF  x82
15B2:  CALL   0B2A
15B6:  BRA    15CA
....................    }  
15B8:  BRA    15CA
....................    else  
....................       return(EXT_Temp);  
15BA:  MOVFF  5F,00
15BE:  MOVFF  60,01
15C2:  MOVFF  61,02
15C6:  MOVFF  62,03
15CA:  GOTO   1FD8 (RETURN)
.................... }  
....................  
.................... #include<stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <LCD_TM.c> 
.................... // Lcd 16x2 in 4 bit mode  
.................... // LCD.C file diver  
.................... // As defined in the following structure the pin connection is as follows: 
.................... // RB4 RS 
.................... // RB5 Enable 
.................... // RB0 DB4 
.................... // RB1 DB5 
.................... // RB2 DB6 
.................... // RB3 DB7 
.................... // 
.................... // LCD pins B0-B3 are not used and RW is not used. 
.................... #define rs PIN_C0      //B4 
.................... //rw connect gnd 
.................... #define enabled PIN_C1 //B5 
.................... #define DB4 PIN_A0 // B0 
.................... #define DB5 PIN_A1 // B1 
.................... #define DB6 PIN_A4 // B2 
.................... #define DB7 PIN_A5 // N3 
.................... char const lcd_type=2; 
.................... char const LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; 
.................... //======================================= 
.................... //======================================= 
.................... void make_out_data(char buffer_data) 
.................... {  
.................... output_bit(DB4,bit_test(buffer_data,0)); 
*
04D0:  BTFSC  x69.0
04D2:  BRA    04D8
04D4:  BCF    F89.0
04D6:  BRA    04DA
04D8:  BSF    F89.0
04DA:  BCF    F92.0
.................... output_bit(DB5,bit_test(buffer_data,1)); 
04DC:  BTFSC  x69.1
04DE:  BRA    04E4
04E0:  BCF    F89.1
04E2:  BRA    04E6
04E4:  BSF    F89.1
04E6:  BCF    F92.1
.................... output_bit(DB6,bit_test(buffer_data,2)); 
04E8:  BTFSC  x69.2
04EA:  BRA    04F0
04EC:  BCF    F89.4
04EE:  BRA    04F2
04F0:  BSF    F89.4
04F2:  BCF    F92.4
.................... output_bit(DB7,bit_test(buffer_data,3)); 
04F4:  BTFSC  x69.3
04F6:  BRA    04FC
04F8:  BCF    F89.5
04FA:  BRA    04FE
04FC:  BSF    F89.5
04FE:  BCF    F92.5
0500:  GOTO   050A (RETURN)
.................... } 
.................... //=================================== 
.................... //=================================== 
.................... void lcd_send_nibble(char buffer_nibble) 
.................... { make_out_data(buffer_nibble); 
0504:  MOVFF  68,69
0508:  BRA    04D0
.................... delay_us(10); 
050A:  MOVLW  10
050C:  MOVWF  00
050E:  DECFSZ 00,F
0510:  BRA    050E
0512:  NOP   
.................... output_high(enabled); 
0514:  BCF    F94.1
0516:  BSF    F8B.1
.................... delay_us(10); 
0518:  MOVLW  10
051A:  MOVWF  00
051C:  DECFSZ 00,F
051E:  BRA    051C
0520:  NOP   
.................... output_low(enabled); 
0522:  BCF    F94.1
0524:  BCF    F8B.1
0526:  RETURN 0
.................... } 
.................... //==================================== 
.................... //==================================== 
.................... void lcd_send_byte( char address, char n ) 
.................... { 
.................... output_low(rs); //rs= = 0; 
0528:  BCF    F94.0
052A:  BCF    F8B.0
.................... delay_ms(1); 
052C:  MOVLW  01
052E:  MOVWF  x72
0530:  RCALL  04AA
.................... output_bit(rs,address);//lcd.rs = address; 
0532:  MOVF   x65,F
0534:  BNZ   053A
0536:  BCF    F8B.0
0538:  BRA    053C
053A:  BSF    F8B.0
053C:  BCF    F94.0
.................... delay_us(20); 
053E:  MOVLW  20
0540:  MOVWF  00
0542:  DECFSZ 00,F
0544:  BRA    0542
0546:  BRA    0548
0548:  NOP   
.................... delay_us(20); 
054A:  MOVLW  20
054C:  MOVWF  00
054E:  DECFSZ 00,F
0550:  BRA    054E
0552:  BRA    0554
0554:  NOP   
.................... output_low(enabled);//lcd.enable = 0; 
0556:  BCF    F94.1
0558:  BCF    F8B.1
.................... lcd_send_nibble(n >> 4); 
055A:  SWAPF  x66,W
055C:  MOVWF  x67
055E:  MOVLW  0F
0560:  ANDWF  x67,F
0562:  MOVFF  67,68
0566:  RCALL  0504
.................... lcd_send_nibble(n & 0xf); 
0568:  MOVF   x66,W
056A:  ANDLW  0F
056C:  MOVWF  x67
056E:  MOVWF  x68
0570:  RCALL  0504
0572:  RETURN 0
.................... } 
.................... //=============================================== 
.................... //=============================================== 
.................... void lcd_init() 
.................... { char i; 
.................... //set_tris_lcd(LCD_WRITE); 
.................... output_low(rs); //lcd.rs = 0; 
0574:  BCF    F94.0
0576:  BCF    F8B.0
.................... //output_low(rw); //lcd.rw = 0; 
.................... output_low(enabled); //lcd.enable = 0; 
0578:  BCF    F94.1
057A:  BCF    F8B.1
.................... delay_ms(200); 
057C:  MOVLW  C8
057E:  MOVWF  x72
0580:  RCALL  04AA
.................... for(i=1;i<=3;++i) 
0582:  MOVLW  01
0584:  MOVWF  53
0586:  MOVF   53,W
0588:  SUBLW  03
058A:  BNC   059C
.................... { 
.................... lcd_send_nibble(3); 
058C:  MOVLW  03
058E:  MOVWF  x68
0590:  RCALL  0504
.................... delay_ms(10); 
0592:  MOVLW  0A
0594:  MOVWF  x72
0596:  RCALL  04AA
0598:  INCF   53,F
059A:  BRA    0586
.................... } 
.................... lcd_send_nibble(2); 
059C:  MOVLW  02
059E:  MOVWF  x68
05A0:  RCALL  0504
.................... for(i=0;i<=3;++i) 
05A2:  CLRF   53
05A4:  MOVF   53,W
05A6:  SUBLW  03
05A8:  BNC   05BC
.................... lcd_send_byte(0,LCD_INIT_STRING[i]); 
05AA:  CLRF   03
05AC:  MOVF   53,W
05AE:  RCALL  0322
05B0:  MOVWF  54
05B2:  CLRF   x65
05B4:  MOVWF  x66
05B6:  RCALL  0528
05B8:  INCF   53,F
05BA:  BRA    05A4
05BC:  RETURN 0
.................... } 
.................... //================================================ 
.................... //================================================ 
.................... void lcd_gotoxy( char x, char y) 
.................... {char address; 
.................... switch(y) { 
*
181C:  MOVLW  01
181E:  SUBWF  x62,W
1820:  ADDLW  FC
1822:  BC    1840
1824:  ADDLW  04
1826:  GOTO   1856
.................... case 1 : address=0x80;break; 
182A:  MOVLW  80
182C:  MOVWF  x63
182E:  BRA    1840
.................... case 2 : address=0xc0;break; 
1830:  MOVLW  C0
1832:  MOVWF  x63
1834:  BRA    1840
.................... case 3 : address=0x94;break; 
1836:  MOVLW  94
1838:  MOVWF  x63
183A:  BRA    1840
.................... case 4 : address=0xd4;break; 
183C:  MOVLW  D4
183E:  MOVWF  x63
.................... } 
.................... address=address+(x-1); 
1840:  MOVLW  01
1842:  SUBWF  x61,W
1844:  ADDWF  x63,F
.................... lcd_send_byte(0,0x80|address); 
1846:  MOVF   x63,W
1848:  IORLW  80
184A:  MOVWF  x64
184C:  CLRF   x65
184E:  MOVWF  x66
1850:  CALL   0528
1854:  RETURN 0
.................... } 
.................... //================================================= 
.................... //================================================= 
.................... void lcd_putc( char c) { 
.................... switch (c) { 
*
1878:  MOVF   x60,W
187A:  XORLW  0C
187C:  BZ    1888
187E:  XORLW  06
1880:  BZ    189C
1882:  XORLW  02
1884:  BZ    18A8
1886:  BRA    18B4
.................... case '\f' : lcd_send_byte(0,1); 
1888:  CLRF   x65
188A:  MOVLW  01
188C:  MOVWF  x66
188E:  CALL   0528
.................... delay_ms(2); break; 
1892:  MOVLW  02
1894:  MOVWF  x72
1896:  CALL   04AA
189A:  BRA    18C0
.................... case '\n' : lcd_gotoxy(1,2); break; 
189C:  MOVLW  01
189E:  MOVWF  x61
18A0:  MOVLW  02
18A2:  MOVWF  x62
18A4:  RCALL  181C
18A6:  BRA    18C0
.................... case '\b' : lcd_send_byte(0,0x10); break; 
18A8:  CLRF   x65
18AA:  MOVLW  10
18AC:  MOVWF  x66
18AE:  CALL   0528
18B2:  BRA    18C0
.................... default : lcd_send_byte(1,c); break; 
18B4:  MOVLW  01
18B6:  MOVWF  x65
18B8:  MOVFF  60,66
18BC:  CALL   0528
.................... } 
18C0:  RETURN 0
.................... } 
.................... //==================================================== 
.................... void LCD_Command(int cm); 
.................... void LCD_ShiftLeft(void); 
.................... void LCD_ShiftRight(void); 
.................... void LCD_MoveRight(char p); 
.................... void LCD_MoveLeft(char p); 
.................... void LCD_String(char*s,int dly); 
....................  
.................... void LCD_Command(int cm){ 
.................... lcd_send_byte(0,cm); 
.................... } 
....................  
.................... void LCD_ShiftLeft(void){ 
.................... lcd_send_byte(0,0x18); 
.................... } 
.................... void LCD_ShiftRight(void){ 
.................... lcd_send_byte(0,0x1C); 
.................... } 
.................... void LCD_MoveRight(char p){ 
.................... char i; 
.................... for(i=0;i<p;i++){ 
.................... LCD_ShiftRight(); 
.................... delay_ms(100); 
.................... } 
.................... } 
.................... void LCD_MoveLeft(char p){ 
.................... char i; 
.................... for(i=0;i<p;i++){ 
.................... LCD_ShiftLeft(); 
.................... delay_ms(100); 
.................... } 
.................... } 
.................... /* 
.................... void strcpy(char*s1,char*s2) { 
.................... while(*s1++ == *s2++); 
.................... } 
.................... */ 
.................... void LCD_String(char*s, int dly) { 
.................... while(*s!=0) { 
.................... lcd_putc(*s++); 
.................... delay_ms(dly); 
.................... } 
.................... } 
....................  
.................... int16 ms; 
....................  
.................... #int_timer2 
.................... void isr_timer2(void) { 
....................    ms++; //keep a running timer that increments every milli-second 
*
0336:  INCF   23,F
0338:  BTFSC  FD8.2
033A:  INCF   24,F
033C:  BCF    F9E.1
033E:  GOTO   0060
.................... } 
....................  
.................... void main() { 
*
1E4A:  CLRF   FF8
1E4C:  BCF    FD0.7
1E4E:  BSF    07.7
1E50:  BSF    FB8.3
1E52:  MOVLW  81
1E54:  MOVWF  FAF
1E56:  MOVLW  00
1E58:  MOVWF  FB0
1E5A:  MOVLW  A6
1E5C:  MOVWF  FAC
1E5E:  MOVLW  90
1E60:  MOVWF  FAB
1E62:  BSF    F93.4
1E64:  BCF    F93.5
1E66:  BCF    F8A.5
1E68:  MOVF   FC1,W
1E6A:  ANDLW  C0
1E6C:  IORLW  0F
1E6E:  MOVWF  FC1
1E70:  CLRF   19
1E72:  CLRF   1A
1E74:  CLRF   1B
1E76:  CLRF   1C
1E78:  CLRF   1D
1E7A:  CLRF   1E
1E7C:  CLRF   3E
1E7E:  CLRF   3D
1E80:  CLRF   3C
1E82:  MOVLW  1D
1E84:  MOVWF  3B
1E86:  BCF    3F.0
1E88:  BSF    3F.1
1E8A:  MOVLW  08
1E8C:  MOVWF  40
1E8E:  MOVLW  03
1E90:  MOVWF  41
....................    //setup_spi(SPI_MASTER | SPI_MODE_1 | SPI_CLK_DIV_64, );  
....................    struct rx_stat rxstat; 
....................    int32 rx_id; 
....................    int in_data[8]; 
....................    int rx_len; 
....................  
.................... //send a request (tx_rtr=1) for 8 bytes of data (tx_len=8) from id 24 (tx_id=24) 
....................    int out_data[8]; 
....................    int32 tx_id=29; // id = 0x29 for MAX31855 temperature 
....................     
....................    int1 tx_rtr=0;// CU LA 1 
....................    int1 tx_ext=1;// CU LA 0 
....................    int tx_len=8; 
....................    int tx_pri=3; 
....................  
....................    int i; 
....................    
....................     
....................    for (i=0;i<8;i++) { 
1E92:  CLRF   42
1E94:  MOVF   42,W
1E96:  SUBLW  07
1E98:  BNC   1EC0
....................       out_data[i]=0x33; 
1E9A:  CLRF   03
1E9C:  MOVF   42,W
1E9E:  ADDLW  33
1EA0:  MOVWF  FE9
1EA2:  MOVLW  00
1EA4:  ADDWFC 03,W
1EA6:  MOVWF  FEA
1EA8:  MOVLW  33
1EAA:  MOVWF  FEF
....................       in_data[i]=0; 
1EAC:  CLRF   03
1EAE:  MOVF   42,W
1EB0:  ADDLW  2A
1EB2:  MOVWF  FE9
1EB4:  MOVLW  00
1EB6:  ADDWFC 03,W
1EB8:  MOVWF  FEA
1EBA:  CLRF   FEF
1EBC:  INCF   42,F
1EBE:  BRA    1E94
....................     
....................       
....................    } 
....................  
....................  //////////////////// 
.................... union conv {  
....................     float f;  
....................     int8 b[4];  
....................   }; 
....................   union conv Max31855exthermo;  // p is alias pointer 
.................... //val1.f=123.45;  
.................... //printf(" %4.4f : %x : %x : %x : %x \r\n",tempp.f,\  
.................... //    val1.b[0],val1.b[1],val1.b[2],val1.b[3]);  
....................     //The four bytes that make up the float  
....................  
.................... //Put four bytes into the second  
.................... /* 
.................... val2.b[0]= 0x86;  
.................... val2.b[1]= 0x6A;  
.................... val2.b[2]= 0x8F;  
.................... val2.b[3]= 0x5C;  
.................... */ 
.................... /* 
.................... out_data[0] = Max31855exthermo.b[0]; 
.................... out_data[1] = Max31855exthermo.b[1]; 
.................... out_data[2] = Max31855exthermo.b[2]; 
.................... out_data[3] = Max31855exthermo.b[3]; 
....................  
.................... */ 
.................... //printf(" %4.4f : %x : %x : %x : %x \r\n",val2.f,\  
.................... //    val2.b[0],val2.b[1],val2.b[2],val2.b[3]);  
.................... //    //The new float value, and the bytes that make it.  
....................  
....................  ////////////////////  
....................  float thermo, exthermo, inthermo; 
....................    printf("\r\n\r\nCCS CAN TRANSFER BME280 DATA\r\n"); 
1EC0:  MOVLW  42
1EC2:  MOVWF  FF6
1EC4:  MOVLW  03
1EC6:  MOVWF  FF7
1EC8:  CALL   0488
....................  
....................    setup_timer_2(T2_DIV_BY_4,79,16);   //setup up timer2 to interrupt every 1ms if using 20Mhz clock 
1ECC:  MOVLW  78
1ECE:  IORLW  05
1ED0:  MOVWF  FCA
1ED2:  MOVLW  4F
1ED4:  MOVWF  FCB
....................    // init lcd 
....................    lcd_init(); 
1ED6:  CALL   0574
....................   // lcd_gotoxy(1,1); 
....................   // printf(lcd_putc,"BSD PROJECT");   
....................    lcd_init(); 
1EDA:  CALL   0574
....................     
....................    can_init(); 
1EDE:  GOTO   0740
....................   
....................     
....................   // can_set_mode(CAN_OP_LOOPBACK); 
....................    
....................    enable_interrupts(INT_TIMER2);   //enable timer2 interrupt 
1EE2:  BSF    F9D.1
....................    enable_interrupts(GLOBAL);       //enable all interrupts (else timer2 wont happen) 
1EE4:  MOVLW  C0
1EE6:  IORWF  FF2,F
....................  
....................    printf("\r\nRunning..."); 
1EE8:  MOVLW  66
1EEA:  MOVWF  FF6
1EEC:  MOVLW  03
1EEE:  MOVWF  FF7
1EF0:  CALL   0488
....................     
....................     
....................    while(TRUE) 
....................    {    
....................          
....................          
....................        thermo = readMAX(); 
1EF4:  CALL   0858
1EF8:  CLRF   x7B
1EFA:  CLRF   x7A
1EFC:  CALL   08CA
1F00:  MOVFF  03,4A
1F04:  MOVFF  02,49
1F08:  MOVFF  01,48
1F0C:  MOVFF  00,47
....................        delay_ms(20); 
1F10:  MOVLW  14
1F12:  MOVWF  x72
1F14:  CALL   04AA
....................        printf("\r\nSPIVAL3 = %X SPIVAL2 = %X SPIVAL1 = %X SPIVAL0 = %X ", spival[3], spival[2], spival[1], spival[0]); 
1F18:  MOVLW  74
1F1A:  MOVWF  FF6
1F1C:  MOVLW  03
1F1E:  MOVWF  FF7
1F20:  MOVLW  0C
1F22:  MOVWF  57
1F24:  CALL   0900
1F28:  MOVFF  1C,54
1F2C:  MOVLW  37
1F2E:  MOVWF  55
1F30:  CALL   0920
1F34:  MOVLW  82
1F36:  MOVWF  FF6
1F38:  MOVLW  03
1F3A:  MOVWF  FF7
1F3C:  MOVLW  0B
1F3E:  MOVWF  57
1F40:  CALL   0900
1F44:  MOVFF  1B,54
1F48:  MOVLW  37
1F4A:  MOVWF  55
1F4C:  CALL   0920
1F50:  MOVLW  8F
1F52:  MOVWF  FF6
1F54:  MOVLW  03
1F56:  MOVWF  FF7
1F58:  MOVLW  0B
1F5A:  MOVWF  57
1F5C:  CALL   0900
1F60:  MOVFF  1A,54
1F64:  MOVLW  37
1F66:  MOVWF  55
1F68:  CALL   0920
1F6C:  MOVLW  9C
1F6E:  MOVWF  FF6
1F70:  MOVLW  03
1F72:  MOVWF  FF7
1F74:  MOVLW  0B
1F76:  MOVWF  57
1F78:  CALL   0900
1F7C:  MOVFF  19,54
1F80:  MOVLW  37
1F82:  MOVWF  55
1F84:  CALL   0920
1F88:  MOVLW  20
1F8A:  BTFSS  F9E.4
1F8C:  BRA    1F8A
1F8E:  MOVWF  FAD
....................         //thermo1 = readExtTemp(); 
....................        delay_ms(10); 
1F90:  MOVLW  0A
1F92:  MOVWF  x72
1F94:  CALL   04AA
....................        // printf("\r\nThermocouple 1 = %f", thermo1); 
....................        exthermo = PreFilter() ; 
1F98:  CALL   0FFA
1F9C:  MOVFF  03,4E
1FA0:  MOVFF  02,4D
1FA4:  MOVFF  01,4C
1FA8:  MOVFF  00,4B
....................        delay_ms(10); 
1FAC:  MOVLW  0A
1FAE:  MOVWF  x72
1FB0:  CALL   04AA
....................        Max31855exthermo.f = exthermo; 
1FB4:  MOVFF  4E,46
1FB8:  MOVFF  4D,45
1FBC:  MOVFF  4C,44
1FC0:  MOVFF  4B,43
....................         
....................        out_data[0] = Max31855exthermo.b[0]; 
1FC4:  MOVFF  43,33
....................        out_data[1] = Max31855exthermo.b[1]; 
1FC8:  MOVFF  44,34
....................        out_data[2] = Max31855exthermo.b[2]; 
1FCC:  MOVFF  45,35
....................        out_data[3] = Max31855exthermo.b[3]; 
1FD0:  MOVFF  46,36
....................         
....................        inthermo = Linearized_TC(); 
1FD4:  GOTO   138A
1FD8:  MOVFF  03,52
1FDC:  MOVFF  02,51
1FE0:  MOVFF  01,50
1FE4:  MOVFF  00,4F
....................        delay_ms(10); 
1FE8:  MOVLW  0A
1FEA:  MOVWF  x72
1FEC:  CALL   04AA
....................        printf("\r\Pre Filter = %f Linearized = %f ", exthermo, inthermo); 
1FF0:  MOVLW  AC
1FF2:  MOVWF  FF6
1FF4:  MOVLW  03
1FF6:  MOVWF  FF7
1FF8:  MOVLW  0E
1FFA:  MOVWF  57
1FFC:  CALL   0900
2000:  MOVLW  89
2002:  MOVWF  FE9
2004:  MOVFF  4E,56
2008:  MOVFF  4D,55
200C:  MOVFF  4C,54
2010:  MOVFF  4B,53
2014:  MOVLW  02
2016:  MOVWF  57
2018:  CALL   169A
201C:  MOVLW  BC
201E:  MOVWF  FF6
2020:  MOVLW  03
2022:  MOVWF  FF7
2024:  MOVLW  0E
2026:  MOVWF  57
2028:  CALL   0900
202C:  MOVLW  89
202E:  MOVWF  FE9
2030:  MOVFF  52,56
2034:  MOVFF  51,55
2038:  MOVFF  50,54
203C:  MOVFF  4F,53
2040:  MOVLW  02
2042:  MOVWF  57
2044:  CALL   169A
2048:  MOVLW  20
204A:  BTFSS  F9E.4
204C:  BRA    204A
204E:  MOVWF  FAD
....................          
....................         lcd_gotoxy(1,1); 
2050:  MOVLW  01
2052:  MOVWF  x61
2054:  MOVWF  x62
2056:  CALL   181C
....................         printf(lcd_putc,"T=%3.1f",exthermo); 
205A:  MOVLW  54
205C:  MOVWF  x60
205E:  RCALL  1878
2060:  MOVLW  3D
2062:  MOVWF  x60
2064:  RCALL  1878
2066:  MOVLW  02
2068:  MOVWF  FE9
206A:  MOVFF  4E,56
206E:  MOVFF  4D,55
2072:  MOVFF  4C,54
2076:  MOVFF  4B,53
207A:  MOVLW  01
207C:  MOVWF  57
207E:  BRA    18C2
....................        lcd_gotoxy(1,2); 
2080:  MOVLW  01
2082:  MOVWF  x61
2084:  MOVLW  02
2086:  MOVWF  x62
2088:  CALL   181C
....................        printf(lcd_putc,"ID:0x29"); 
208C:  MOVLW  CE
208E:  MOVWF  FF6
2090:  MOVLW  03
2092:  MOVWF  FF7
2094:  BRA    1A3E
....................        // lcd_gotoxy(1,2); 
....................        // printf(lcd_putc,"T=%3.1f",inthermo); 
....................          
....................       if ( can_kbhit() )   //if data is waiting in buffer... 
2096:  BTFSC  F60.7
2098:  BRA    20A2
209A:  MOVLB  F
209C:  BTFSS  x50.7
209E:  BRA    2324
20A0:  MOVLB  0
....................       { 
....................          if(can_getd(rx_id, &in_data[0], rx_len, rxstat)) { //...then get data from buffer 
20A2:  CLRF   54
20A4:  MOVLW  2A
20A6:  MOVWF  53
*
21A4:  MOVF   01,F
21A6:  BTFSC  FD8.2
21A8:  BRA    2314
....................             printf("\r\nGOT: BUFF=%U ID=%LU LEN=%U OVF=%U ", rxstat.buffer, rx_id, rx_len, rxstat.err_ovfl); 
21AA:  MOVLW  00
21AC:  BTFSC  25.4
21AE:  MOVLW  01
21B0:  MOVWF  53
21B2:  MOVLW  00
21B4:  BTFSC  25.0
21B6:  MOVLW  01
21B8:  MOVWF  54
21BA:  MOVLW  D6
21BC:  MOVWF  FF6
21BE:  MOVLW  03
21C0:  MOVWF  FF7
21C2:  MOVLW  0C
21C4:  MOVWF  57
21C6:  MOVLB  0
21C8:  CALL   0900
21CC:  MOVFF  53,57
21D0:  MOVLW  1B
21D2:  MOVWF  58
21D4:  RCALL  1C6A
21D6:  MOVLW  E4
21D8:  MOVWF  FF6
21DA:  MOVLW  03
21DC:  MOVWF  FF7
21DE:  MOVLW  04
21E0:  MOVWF  57
21E2:  CALL   0900
21E6:  MOVLW  41
21E8:  MOVWF  FE9
21EA:  MOVFF  29,58
21EE:  MOVFF  28,57
21F2:  MOVFF  27,56
21F6:  MOVFF  26,55
21FA:  RCALL  1CD6
21FC:  MOVLW  EB
21FE:  MOVWF  FF6
2200:  MOVLW  03
2202:  MOVWF  FF7
2204:  MOVLW  05
2206:  MOVWF  57
2208:  CALL   0900
220C:  MOVFF  32,57
2210:  MOVLW  1B
2212:  MOVWF  58
2214:  RCALL  1C6A
2216:  MOVLW  F2
2218:  MOVWF  FF6
221A:  MOVLW  03
221C:  MOVWF  FF7
221E:  MOVLW  05
2220:  MOVWF  57
2222:  CALL   0900
2226:  MOVFF  54,57
222A:  MOVLW  1B
222C:  MOVWF  58
222E:  RCALL  1C6A
2230:  MOVLW  20
2232:  BTFSS  F9E.4
2234:  BRA    2232
2236:  MOVWF  FAD
....................             printf("FILT=%U RTR=%U EXT=%U INV=%U", rxstat.filthit, rxstat.rtr, rxstat.ext, rxstat.inv); 
2238:  MOVFF  25,00
223C:  RRCF   25,W
223E:  ANDLW  07
2240:  MOVWF  53
2242:  MOVLW  00
2244:  BTFSC  25.5
2246:  MOVLW  01
2248:  MOVWF  54
224A:  MOVLW  00
224C:  BTFSC  25.6
224E:  MOVLW  01
2250:  MOVWF  55
2252:  MOVLW  00
2254:  BTFSC  25.7
2256:  MOVLW  01
2258:  MOVWF  56
225A:  MOVLW  FC
225C:  MOVWF  FF6
225E:  MOVLW  03
2260:  MOVWF  FF7
2262:  MOVLW  05
2264:  MOVWF  57
2266:  CALL   0900
226A:  MOVFF  53,57
226E:  MOVLW  1B
2270:  MOVWF  58
2272:  RCALL  1C6A
2274:  MOVLW  03
2276:  MOVWF  FF6
2278:  MOVLW  04
227A:  MOVWF  FF7
227C:  MOVLW  05
227E:  MOVWF  57
2280:  CALL   0900
2284:  MOVFF  54,57
2288:  MOVLW  1B
228A:  MOVWF  58
228C:  RCALL  1C6A
228E:  MOVLW  0A
2290:  MOVWF  FF6
2292:  MOVLW  04
2294:  MOVWF  FF7
2296:  MOVLW  05
2298:  MOVWF  57
229A:  CALL   0900
229E:  MOVFF  55,57
22A2:  MOVLW  1B
22A4:  MOVWF  58
22A6:  RCALL  1C6A
22A8:  MOVLW  11
22AA:  MOVWF  FF6
22AC:  MOVLW  04
22AE:  MOVWF  FF7
22B0:  MOVLW  05
22B2:  MOVWF  57
22B4:  CALL   0900
22B8:  MOVFF  56,57
22BC:  MOVLW  1B
22BE:  MOVWF  58
22C0:  RCALL  1C6A
....................             printf("\r\n    DATA = "); 
22C2:  MOVLW  1A
22C4:  MOVWF  FF6
22C6:  MOVLW  04
22C8:  MOVWF  FF7
22CA:  CALL   0488
....................             for (i=0;i<rx_len;i++) { 
22CE:  CLRF   42
22D0:  MOVF   32,W
22D2:  SUBWF  42,W
22D4:  BC    2300
....................                printf("%X ",in_data[i]); 
22D6:  CLRF   03
22D8:  MOVF   42,W
22DA:  ADDLW  2A
22DC:  MOVWF  FE9
22DE:  MOVLW  00
22E0:  ADDWFC 03,W
22E2:  MOVWF  FEA
22E4:  MOVFF  FEF,53
22E8:  MOVFF  53,54
22EC:  MOVLW  37
22EE:  MOVWF  55
22F0:  CALL   0920
22F4:  MOVLW  20
22F6:  BTFSS  F9E.4
22F8:  BRA    22F6
22FA:  MOVWF  FAD
22FC:  INCF   42,F
22FE:  BRA    22D0
....................             } 
....................             printf("\r\n"); 
2300:  MOVLW  0D
2302:  BTFSS  F9E.4
2304:  BRA    2302
2306:  MOVWF  FAD
2308:  MOVLW  0A
230A:  BTFSS  F9E.4
230C:  BRA    230A
230E:  MOVWF  FAD
....................          } 
2310:  BRA    2322
2312:  MOVLB  F
....................          else { 
....................             printf("\r\nFAIL on GETD\r\n"); 
2314:  MOVLW  28
2316:  MOVWF  FF6
2318:  MOVLW  04
231A:  MOVWF  FF7
231C:  MOVLB  0
231E:  CALL   0488
2322:  MOVLB  F
....................          } 
....................  
....................       } 
....................       //every two seconds, send new data if transmit buffer is empty 
....................       if ( can_tbe() && (ms > 2000)) 
2324:  BTFSS  x40.3
2326:  BRA    2330
2328:  BTFSS  x30.3
232A:  BRA    2330
232C:  BTFSC  x20.3
232E:  BRA    24BE
2330:  MOVF   24,W
2332:  SUBLW  06
2334:  BTFSC  FD8.0
2336:  BRA    24BE
2338:  XORLW  FF
233A:  BNZ   2344
233C:  MOVF   23,W
233E:  SUBLW  D0
2340:  BTFSC  FD8.0
2342:  BRA    24BE
....................       { 
....................          ms=0; 
2344:  CLRF   24
2346:  CLRF   23
....................          i=can_putd(tx_id, out_data, tx_len,tx_pri,tx_ext,tx_rtr); //put data on transmit buffer 
2348:  MOVLW  00
234A:  BTFSC  3F.1
234C:  MOVLW  01
234E:  MOVWF  53
2350:  MOVLW  00
2352:  BTFSC  3F.0
2354:  MOVLW  01
2356:  MOVWF  54
2358:  MOVFF  3E,58
235C:  MOVFF  3D,57
2360:  MOVFF  3C,56
2364:  MOVFF  3B,55
2368:  CLRF   5A
236A:  MOVLW  33
236C:  MOVWF  59
236E:  MOVFF  40,5B
2372:  MOVFF  41,5C
2376:  MOVFF  53,5D
237A:  MOVFF  54,5E
237E:  MOVLB  0
2380:  BRA    1D7C
2382:  MOVFF  01,42
....................          if (i != 0xFF) { //success, a transmit buffer was open 
2386:  INCFSZ 42,W
2388:  BRA    238C
238A:  BRA    24B0
....................             printf("\r\nPUT %U: ID=%LU LEN=%U ", i, tx_id, tx_len);  //i return 1 if transmit success 
238C:  MOVLW  3A
238E:  MOVWF  FF6
2390:  MOVLW  04
2392:  MOVWF  FF7
2394:  MOVLW  06
2396:  MOVWF  57
2398:  CALL   0900
239C:  MOVFF  42,57
23A0:  MOVLW  1B
23A2:  MOVWF  58
23A4:  RCALL  1C6A
23A6:  MOVLW  42
23A8:  MOVWF  FF6
23AA:  MOVLW  04
23AC:  MOVWF  FF7
23AE:  MOVLW  05
23B0:  MOVWF  57
23B2:  CALL   0900
23B6:  MOVLW  41
23B8:  MOVWF  FE9
23BA:  MOVFF  3E,58
23BE:  MOVFF  3D,57
23C2:  MOVFF  3C,56
23C6:  MOVFF  3B,55
23CA:  RCALL  1CD6
23CC:  MOVLW  4A
23CE:  MOVWF  FF6
23D0:  MOVLW  04
23D2:  MOVWF  FF7
23D4:  MOVLW  05
23D6:  MOVWF  57
23D8:  CALL   0900
23DC:  MOVFF  40,57
23E0:  MOVLW  1B
23E2:  MOVWF  58
23E4:  RCALL  1C6A
23E6:  MOVLW  20
23E8:  BTFSS  F9E.4
23EA:  BRA    23E8
23EC:  MOVWF  FAD
....................             printf("PRI=%U EXT=%U RTR=%U\r\n   DATA = ", tx_pri, tx_ext, tx_rtr); 
23EE:  MOVLW  00
23F0:  BTFSC  3F.1
23F2:  MOVLW  01
23F4:  MOVWF  53
23F6:  MOVLW  00
23F8:  BTFSC  3F.0
23FA:  MOVLW  01
23FC:  MOVWF  54
23FE:  MOVLW  54
2400:  MOVWF  FF6
2402:  MOVLW  04
2404:  MOVWF  FF7
2406:  MOVLW  04
2408:  MOVWF  57
240A:  CALL   0900
240E:  MOVFF  41,57
2412:  MOVLW  1B
2414:  MOVWF  58
2416:  RCALL  1C6A
2418:  MOVLW  5A
241A:  MOVWF  FF6
241C:  MOVLW  04
241E:  MOVWF  FF7
2420:  MOVLW  05
2422:  MOVWF  57
2424:  CALL   0900
2428:  MOVFF  53,57
242C:  MOVLW  1B
242E:  MOVWF  58
2430:  RCALL  1C6A
2432:  MOVLW  61
2434:  MOVWF  FF6
2436:  MOVLW  04
2438:  MOVWF  FF7
243A:  MOVLW  05
243C:  MOVWF  57
243E:  CALL   0900
2442:  MOVFF  54,57
2446:  MOVLW  1B
2448:  MOVWF  58
244A:  RCALL  1C6A
244C:  MOVLW  68
244E:  MOVWF  FF6
2450:  MOVLW  04
2452:  MOVWF  FF7
2454:  MOVLW  0C
2456:  MOVWF  57
2458:  CALL   0900
....................             //  printf("\r\nID=%X", out_data[0]); 
....................             for (i=0;i<tx_len;i++) { 
245C:  CLRF   42
245E:  MOVF   40,W
2460:  SUBWF  42,W
2462:  BC    249E
....................                printf("\r\n%X ",out_data[i]); 
2464:  CLRF   03
2466:  MOVF   42,W
2468:  ADDLW  33
246A:  MOVWF  FE9
246C:  MOVLW  00
246E:  ADDWFC 03,W
2470:  MOVWF  FEA
2472:  MOVFF  FEF,53
2476:  MOVLW  0D
2478:  BTFSS  F9E.4
247A:  BRA    2478
247C:  MOVWF  FAD
247E:  MOVLW  0A
2480:  BTFSS  F9E.4
2482:  BRA    2480
2484:  MOVWF  FAD
2486:  MOVFF  53,54
248A:  MOVLW  37
248C:  MOVWF  55
248E:  CALL   0920
2492:  MOVLW  20
2494:  BTFSS  F9E.4
2496:  BRA    2494
2498:  MOVWF  FAD
249A:  INCF   42,F
249C:  BRA    245E
....................             } 
....................             printf("\r\n"); 
249E:  MOVLW  0D
24A0:  BTFSS  F9E.4
24A2:  BRA    24A0
24A4:  MOVWF  FAD
24A6:  MOVLW  0A
24A8:  BTFSS  F9E.4
24AA:  BRA    24A8
24AC:  MOVWF  FAD
....................          } 
24AE:  BRA    24BC
....................          else { //fail, no transmit buffer was open 
....................             printf("\r\nFAIL on PUTD\r\n"); 
24B0:  MOVLW  76
24B2:  MOVWF  FF6
24B4:  MOVLW  04
24B6:  MOVWF  FF7
24B8:  CALL   0488
24BC:  MOVLB  F
....................          
....................          } 
....................          
....................       } 
....................     
....................        
....................      delay_ms(500);  
24BE:  MOVLW  02
24C0:  MOVWF  53
24C2:  MOVLW  FA
24C4:  MOVLB  0
24C6:  MOVWF  x72
24C8:  CALL   04AA
24CC:  DECFSZ 53,F
24CE:  BRA    24D2
24D0:  BRA    24D6
24D2:  MOVLB  F
24D4:  BRA    24C2
24D6:  BRA    1EF4
....................    } 
.................... } 
24D8:  SLEEP 

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 1E1E   PUT BROWNOUT BORV21 NOWDT WDT32768
   Word  3: 8600   PBADEN LPT1OSC MCLR
   Word  4: 0091   STVREN NOLVP BBSIZ2K NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
